/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: test_heart.xml

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;

    
using System.Reflection;    
    
//[assembly: AssemblyTitle("Mavlink Classes")]
//[assembly: AssemblyDescription("Generated Message Classes for Mavlink. See http://qgroundcontrol.org/mavlink/start")]
//[assembly: AssemblyProduct("Mavlink")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]

    namespace MavLink
{

}

    
   
namespace MavLink
{

    public abstract class MavlinkMessage
    {
        public abstract int Serialize(byte[] bytes, ref int offset);
    }

	/// <summary>
	/// The heartbeat message shows that a system or component is present and responding. The type and autopilot fields (along with the message component id), allow the receiving system to treat further messages from this system appropriately (e.g. by laying out the user interface based on the autopilot). This microservice is documented at https://mavlink.io/en/services/heartbeat.html
	/// </summary>
	public class Msg_heartbeat : MavlinkMessage
    {

		/// <summary>
		/// Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type.
		/// </summary>
		public byte type;

		/// <summary>
		/// Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.
		/// </summary>
		public byte autopilot;

		/// <summary>
		/// System mode bitmap.
		/// </summary>
		public byte base_mode;

		/// <summary>
		/// A bitfield for use for autopilot-specific flags
		/// </summary>
		public UInt32 custom_mode;

		/// <summary>
		/// System status flag.
		/// </summary>
		public byte system_status;

		/// <summary>
		/// MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version
		/// </summary>
		public byte mavlink_version;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HEARTBEAT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows whether the system is currently active or not and if an emergency occurred. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occurred it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.
	/// </summary>
	public class Msg_sys_status : MavlinkMessage
    {

		/// <summary>
		/// Bitmap showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present.
		/// </summary>
		public UInt32 onboard_control_sensors_present;

		/// <summary>
		/// Bitmap showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled.
		/// </summary>
		public UInt32 onboard_control_sensors_enabled;

		/// <summary>
		/// Bitmap showing which onboard controllers and sensors have an error (or are operational). Value of 0: error. Value of 1: healthy.
		/// </summary>
		public UInt32 onboard_control_sensors_health;

		/// <summary>
		/// Maximum usage in percent of the mainloop time. Values: [0-1000] - should always be below 1000
		/// </summary>
		public UInt16 load;

		/// <summary>
		/// Battery voltage, UINT16_MAX: Voltage not sent by autopilot
		/// </summary>
		public UInt16 voltage_battery;

		/// <summary>
		/// Battery current, -1: Current not sent by autopilot
		/// </summary>
		public Int16 current_battery;

		/// <summary>
		/// Battery energy remaining, -1: Battery remaining energy not sent by autopilot
		/// </summary>
		public sbyte battery_remaining;

		/// <summary>
		/// Communication drop rate, (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
		/// </summary>
		public UInt16 drop_rate_comm;

		/// <summary>
		/// Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
		/// </summary>
		public UInt16 errors_comm;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count1;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count2;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count3;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count4;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SYS_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The system time is the time of the master clock, typically the computer clock of the main onboard computer.
	/// </summary>
	public class Msg_system_time : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX epoch time).
		/// </summary>
		public UInt64 time_unix_usec;

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SYSTEM_TIME(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at https://mavlink.io/en/services/ping.html
	/// </summary>
	public class Msg_ping : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// PING sequence
		/// </summary>
		public UInt32 seq;

		/// <summary>
		/// 0: request ping from all receiving systems. If greater than 0: message is a ping response and number is the system id of the requesting system
		/// </summary>
		public byte target_system;

		/// <summary>
		/// 0: request ping from all receiving components. If greater than 0: message is a ping response and number is the component id of the requesting component.
		/// </summary>
		public byte target_component;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_PING(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request to control this MAV
	/// </summary>
	public class Msg_change_operator_control : MavlinkMessage
    {

		/// <summary>
		/// System the GCS requests control for
		/// </summary>
		public byte target_system;

		/// <summary>
		/// 0: request control of this MAV, 1: Release control of this MAV
		/// </summary>
		public byte control_request;

		/// <summary>
		/// 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
		/// </summary>
		public byte version;

		/// <summary>
		/// Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and "!?,.-"
		/// </summary>
		public byte[] passkey; // Array size 25

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_CHANGE_OPERATOR_CONTROL(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Accept / deny control of this MAV
	/// </summary>
	public class Msg_change_operator_control_ack : MavlinkMessage
    {

		/// <summary>
		/// ID of the GCS this message 
		/// </summary>
		public byte gcs_system_id;

		/// <summary>
		/// 0: request control of this MAV, 1: Release control of this MAV
		/// </summary>
		public byte control_request;

		/// <summary>
		/// 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
		/// </summary>
		public byte ack;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_CHANGE_OPERATOR_CONTROL_ACK(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety.
	/// </summary>
	public class Msg_auth_key : MavlinkMessage
    {
		public byte[] key; // Array size 32

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_AUTH_KEY(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Status generated in each node in the communication chain and injected into MAVLink stream.
	/// </summary>
	public class Msg_link_node_status : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt64 timestamp;

		/// <summary>
		/// Remaining free transmit buffer space
		/// </summary>
		public byte tx_buf;

		/// <summary>
		/// Remaining free receive buffer space
		/// </summary>
		public byte rx_buf;

		/// <summary>
		/// Transmit rate
		/// </summary>
		public UInt32 tx_rate;

		/// <summary>
		/// Receive rate
		/// </summary>
		public UInt32 rx_rate;

		/// <summary>
		/// Number of bytes that could not be parsed correctly.
		/// </summary>
		public UInt16 rx_parse_err;

		/// <summary>
		/// Transmit buffer overflows. This number wraps around as it reaches UINT16_MAX
		/// </summary>
		public UInt16 tx_overflows;

		/// <summary>
		/// Receive buffer overflows. This number wraps around as it reaches UINT16_MAX
		/// </summary>
		public UInt16 rx_overflows;

		/// <summary>
		/// Messages sent
		/// </summary>
		public UInt32 messages_sent;

		/// <summary>
		/// Messages received (estimated from counting seq)
		/// </summary>
		public UInt32 messages_received;

		/// <summary>
		/// Messages lost (estimated from counting seq)
		/// </summary>
		public UInt32 messages_lost;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LINK_NODE_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component.
	/// </summary>
	public class Msg_set_mode : MavlinkMessage
    {

		/// <summary>
		/// The system setting the mode
		/// </summary>
		public byte target_system;

		/// <summary>
		/// The new base mode.
		/// </summary>
		public byte base_mode;

		/// <summary>
		/// The new autopilot-specific mode. This field can be ignored by an autopilot.
		/// </summary>
		public UInt32 custom_mode;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SET_MODE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also https://mavlink.io/en/services/parameter.html for a full documentation of QGroundControl and IMU code.
	/// </summary>
	public class Msg_param_request_read : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
		/// </summary>
		public byte[] param_id; // Array size 16

		/// <summary>
		/// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
		/// </summary>
		public Int16 param_index;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_PARAM_REQUEST_READ(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request all parameters of this component. After this request, all parameters are emitted. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
	/// </summary>
	public class Msg_param_request_list : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_PARAM_REQUEST_LIST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
	/// </summary>
	public class Msg_param_value : MavlinkMessage
    {

		/// <summary>
		/// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
		/// </summary>
		public byte[] param_id; // Array size 16

		/// <summary>
		/// Onboard parameter value
		/// </summary>
		public float param_value;

		/// <summary>
		/// Onboard parameter type.
		/// </summary>
		public byte param_type;

		/// <summary>
		/// Total number of onboard parameters
		/// </summary>
		public UInt16 param_count;

		/// <summary>
		/// Index of this onboard parameter
		/// </summary>
		public UInt16 param_index;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_PARAM_VALUE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Set a parameter value (write new value to permanent storage). IMPORTANT: The receiving component should acknowledge the new parameter value by sending a PARAM_VALUE message to all communication partners. This will also ensure that multiple GCS all have an up-to-date list of all parameters. If the sending GCS did not receive a PARAM_VALUE message within its timeout time, it should re-send the PARAM_SET message. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
	/// </summary>
	public class Msg_param_set : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
		/// </summary>
		public byte[] param_id; // Array size 16

		/// <summary>
		/// Onboard parameter value
		/// </summary>
		public float param_value;

		/// <summary>
		/// Onboard parameter type.
		/// </summary>
		public byte param_type;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_PARAM_SET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The global position, as returned by the Global Positioning System (GPS). This is
	///                NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate.
	/// </summary>
	public class Msg_gps_raw_int : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// GPS fix type.
		/// </summary>
		public byte fix_type;

		/// <summary>
		/// Latitude (WGS84, EGM96 ellipsoid)
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude (WGS84, EGM96 ellipsoid)
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude (MSL). Positive for up. Note that virtually all GPS modules provide the MSL altitude in addition to the WGS84 altitude.
		/// </summary>
		public Int32 alt;

		/// <summary>
		/// GPS HDOP horizontal dilution of position (unitless). If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 eph;

		/// <summary>
		/// GPS VDOP vertical dilution of position (unitless). If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 epv;

		/// <summary>
		/// GPS ground speed. If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 vel;

		/// <summary>
		/// Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 cog;

		/// <summary>
		/// Number of satellites visible. If unknown, set to 255
		/// </summary>
		public byte satellites_visible;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS_RAW_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate. This message can contain information for up to 20 satellites.
	/// </summary>
	public class Msg_gps_status : MavlinkMessage
    {

		/// <summary>
		/// Number of satellites visible
		/// </summary>
		public byte satellites_visible;

		/// <summary>
		/// Global satellite ID
		/// </summary>
		public byte[] satellite_prn; // Array size 20

		/// <summary>
		/// 0: Satellite not used, 1: used for localization
		/// </summary>
		public byte[] satellite_used; // Array size 20

		/// <summary>
		/// Elevation (0: right on top of receiver, 90: on the horizon) of satellite
		/// </summary>
		public byte[] satellite_elevation; // Array size 20

		/// <summary>
		/// Direction of satellite, 0: 0 deg, 255: 360 deg.
		/// </summary>
		public byte[] satellite_azimuth; // Array size 20

		/// <summary>
		/// Signal to noise ratio of satellite
		/// </summary>
		public byte[] satellite_snr; // Array size 20

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units
	/// </summary>
	public class Msg_scaled_imu : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// X acceleration
		/// </summary>
		public Int16 xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public Int16 yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public Int16 zacc;

		/// <summary>
		/// Angular speed around X axis
		/// </summary>
		public Int16 xgyro;

		/// <summary>
		/// Angular speed around Y axis
		/// </summary>
		public Int16 ygyro;

		/// <summary>
		/// Angular speed around Z axis
		/// </summary>
		public Int16 zgyro;

		/// <summary>
		/// X Magnetic field
		/// </summary>
		public Int16 xmag;

		/// <summary>
		/// Y Magnetic field
		/// </summary>
		public Int16 ymag;

		/// <summary>
		/// Z Magnetic field
		/// </summary>
		public Int16 zmag;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SCALED_IMU(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The RAW IMU readings for a 9DOF sensor, which is identified by the id (default IMU1). This message should always contain the true raw values without any scaling to allow data capture and system debugging.
	/// </summary>
	public class Msg_raw_imu : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// X acceleration (raw)
		/// </summary>
		public Int16 xacc;

		/// <summary>
		/// Y acceleration (raw)
		/// </summary>
		public Int16 yacc;

		/// <summary>
		/// Z acceleration (raw)
		/// </summary>
		public Int16 zacc;

		/// <summary>
		/// Angular speed around X axis (raw)
		/// </summary>
		public Int16 xgyro;

		/// <summary>
		/// Angular speed around Y axis (raw)
		/// </summary>
		public Int16 ygyro;

		/// <summary>
		/// Angular speed around Z axis (raw)
		/// </summary>
		public Int16 zgyro;

		/// <summary>
		/// X Magnetic field (raw)
		/// </summary>
		public Int16 xmag;

		/// <summary>
		/// Y Magnetic field (raw)
		/// </summary>
		public Int16 ymag;

		/// <summary>
		/// Z Magnetic field (raw)
		/// </summary>
		public Int16 zmag;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RAW_IMU(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values.
	/// </summary>
	public class Msg_raw_pressure : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Absolute pressure (raw)
		/// </summary>
		public Int16 press_abs;

		/// <summary>
		/// Differential pressure 1 (raw, 0 if nonexistent)
		/// </summary>
		public Int16 press_diff1;

		/// <summary>
		/// Differential pressure 2 (raw, 0 if nonexistent)
		/// </summary>
		public Int16 press_diff2;

		/// <summary>
		/// Raw Temperature measurement (raw)
		/// </summary>
		public Int16 temperature;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RAW_PRESSURE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field.
	/// </summary>
	public class Msg_scaled_pressure : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Absolute pressure
		/// </summary>
		public float press_abs;

		/// <summary>
		/// Differential pressure 1
		/// </summary>
		public float press_diff;
		public Int16 temperature;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SCALED_PRESSURE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right).
	/// </summary>
	public class Msg_attitude : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Roll angle (-pi..+pi)
		/// </summary>
		public float roll;

		/// <summary>
		/// Pitch angle (-pi..+pi)
		/// </summary>
		public float pitch;

		/// <summary>
		/// Yaw angle (-pi..+pi)
		/// </summary>
		public float yaw;

		/// <summary>
		/// Roll angular speed
		/// </summary>
		public float rollspeed;

		/// <summary>
		/// Pitch angular speed
		/// </summary>
		public float pitchspeed;

		/// <summary>
		/// Yaw angular speed
		/// </summary>
		public float yawspeed;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ATTITUDE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
	/// </summary>
	public class Msg_attitude_quaternion : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Quaternion component 1, w (1 in null-rotation)
		/// </summary>
		public float q1;

		/// <summary>
		/// Quaternion component 2, x (0 in null-rotation)
		/// </summary>
		public float q2;

		/// <summary>
		/// Quaternion component 3, y (0 in null-rotation)
		/// </summary>
		public float q3;

		/// <summary>
		/// Quaternion component 4, z (0 in null-rotation)
		/// </summary>
		public float q4;

		/// <summary>
		/// Roll angular speed
		/// </summary>
		public float rollspeed;

		/// <summary>
		/// Pitch angular speed
		/// </summary>
		public float pitchspeed;

		/// <summary>
		/// Yaw angular speed
		/// </summary>
		public float yawspeed;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ATTITUDE_QUATERNION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
	/// </summary>
	public class Msg_local_position_ned : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// X Position
		/// </summary>
		public float x;

		/// <summary>
		/// Y Position
		/// </summary>
		public float y;

		/// <summary>
		/// Z Position
		/// </summary>
		public float z;

		/// <summary>
		/// X Speed
		/// </summary>
		public float vx;

		/// <summary>
		/// Y Speed
		/// </summary>
		public float vy;

		/// <summary>
		/// Z Speed
		/// </summary>
		public float vz;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOCAL_POSITION_NED(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It
	///               is designed as scaled integer message since the resolution of float is not sufficient.
	/// </summary>
	public class Msg_global_position_int : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Latitude, expressed
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude, expressed
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude (MSL). Note that virtually all GPS modules provide both WGS84 and MSL.
		/// </summary>
		public Int32 alt;

		/// <summary>
		/// Altitude above ground
		/// </summary>
		public Int32 relative_alt;

		/// <summary>
		/// Ground X Speed (Latitude, positive north)
		/// </summary>
		public Int16 vx;

		/// <summary>
		/// Ground Y Speed (Longitude, positive east)
		/// </summary>
		public Int16 vy;

		/// <summary>
		/// Ground Z Speed (Altitude, positive down)
		/// </summary>
		public Int16 vz;

		/// <summary>
		/// Vehicle heading (yaw angle), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 hdg;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GLOBAL_POSITION_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The scaled values of the RC channels received: (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to UINT16_MAX.
	/// </summary>
	public class Msg_rc_channels_scaled : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
		/// </summary>
		public byte port;

		/// <summary>
		/// RC channel 1 value scaled.
		/// </summary>
		public Int16 chan1_scaled;

		/// <summary>
		/// RC channel 2 value scaled.
		/// </summary>
		public Int16 chan2_scaled;

		/// <summary>
		/// RC channel 3 value scaled.
		/// </summary>
		public Int16 chan3_scaled;

		/// <summary>
		/// RC channel 4 value scaled.
		/// </summary>
		public Int16 chan4_scaled;

		/// <summary>
		/// RC channel 5 value scaled.
		/// </summary>
		public Int16 chan5_scaled;

		/// <summary>
		/// RC channel 6 value scaled.
		/// </summary>
		public Int16 chan6_scaled;

		/// <summary>
		/// RC channel 7 value scaled.
		/// </summary>
		public Int16 chan7_scaled;

		/// <summary>
		/// RC channel 8 value scaled.
		/// </summary>
		public Int16 chan8_scaled;

		/// <summary>
		/// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte rssi;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RC_CHANNELS_SCALED(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
	/// </summary>
	public class Msg_rc_channels_raw : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
		/// </summary>
		public byte port;

		/// <summary>
		/// RC channel 1 value.
		/// </summary>
		public UInt16 chan1_raw;

		/// <summary>
		/// RC channel 2 value.
		/// </summary>
		public UInt16 chan2_raw;

		/// <summary>
		/// RC channel 3 value.
		/// </summary>
		public UInt16 chan3_raw;

		/// <summary>
		/// RC channel 4 value.
		/// </summary>
		public UInt16 chan4_raw;

		/// <summary>
		/// RC channel 5 value.
		/// </summary>
		public UInt16 chan5_raw;

		/// <summary>
		/// RC channel 6 value.
		/// </summary>
		public UInt16 chan6_raw;

		/// <summary>
		/// RC channel 7 value.
		/// </summary>
		public UInt16 chan7_raw;

		/// <summary>
		/// RC channel 8 value.
		/// </summary>
		public UInt16 chan8_raw;

		/// <summary>
		/// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte rssi;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RC_CHANNELS_RAW(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Superseded by ACTUATOR_OUTPUT_STATUS. The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.
	/// </summary>
	public class Msg_servo_output_raw : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt32 time_usec;

		/// <summary>
		/// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
		/// </summary>
		public byte port;

		/// <summary>
		/// Servo output 1 value
		/// </summary>
		public UInt16 servo1_raw;

		/// <summary>
		/// Servo output 2 value
		/// </summary>
		public UInt16 servo2_raw;

		/// <summary>
		/// Servo output 3 value
		/// </summary>
		public UInt16 servo3_raw;

		/// <summary>
		/// Servo output 4 value
		/// </summary>
		public UInt16 servo4_raw;

		/// <summary>
		/// Servo output 5 value
		/// </summary>
		public UInt16 servo5_raw;

		/// <summary>
		/// Servo output 6 value
		/// </summary>
		public UInt16 servo6_raw;

		/// <summary>
		/// Servo output 7 value
		/// </summary>
		public UInt16 servo7_raw;

		/// <summary>
		/// Servo output 8 value
		/// </summary>
		public UInt16 servo8_raw;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SERVO_OUTPUT_RAW(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request a partial list of mission items from the system/component. https://mavlink.io/en/services/mission.html. If start and end index are the same, just send one waypoint.
	/// </summary>
	public class Msg_mission_request_partial_list : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Start index
		/// </summary>
		public Int16 start_index;

		/// <summary>
		/// End index, -1 by default (-1: send list to end). Else a valid index of the list
		/// </summary>
		public Int16 end_index;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_REQUEST_PARTIAL_LIST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!
	/// </summary>
	public class Msg_mission_write_partial_list : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Start index. Must be smaller / equal to the largest index of the current onboard list.
		/// </summary>
		public Int16 start_index;

		/// <summary>
		/// End index, equal or greater than start index.
		/// </summary>
		public Int16 end_index;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_WRITE_PARTIAL_LIST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Message encoding a mission item. This message is emitted to announce
	///                the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN may be used to indicate an optional/default value (e.g. to use the system's current latitude or yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
	/// </summary>
	public class Msg_mission_item : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Sequence
		/// </summary>
		public UInt16 seq;

		/// <summary>
		/// The coordinate system of the waypoint.
		/// </summary>
		public byte frame;

		/// <summary>
		/// The scheduled action for the waypoint.
		/// </summary>
		public UInt16 command;

		/// <summary>
		/// false:0, true:1
		/// </summary>
		public byte current;

		/// <summary>
		/// Autocontinue to next waypoint
		/// </summary>
		public byte autocontinue;

		/// <summary>
		/// PARAM1, see MAV_CMD enum
		/// </summary>
		public float param1;

		/// <summary>
		/// PARAM2, see MAV_CMD enum
		/// </summary>
		public float param2;

		/// <summary>
		/// PARAM3, see MAV_CMD enum
		/// </summary>
		public float param3;

		/// <summary>
		/// PARAM4, see MAV_CMD enum
		/// </summary>
		public float param4;

		/// <summary>
		/// PARAM5 / local: X coordinate, global: latitude
		/// </summary>
		public float x;

		/// <summary>
		/// PARAM6 / local: Y coordinate, global: longitude
		/// </summary>
		public float y;

		/// <summary>
		/// PARAM7 / local: Z coordinate, global: altitude (relative or absolute, depending on frame).
		/// </summary>
		public float z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_ITEM(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. https://mavlink.io/en/services/mission.html
	/// </summary>
	public class Msg_mission_request : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Sequence
		/// </summary>
		public UInt16 seq;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_REQUEST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between).
	/// </summary>
	public class Msg_mission_set_current : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Sequence
		/// </summary>
		public UInt16 seq;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_SET_CURRENT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Message that announces the sequence number of the current active mission item. The MAV will fly towards this mission item.
	/// </summary>
	public class Msg_mission_current : MavlinkMessage
    {

		/// <summary>
		/// Sequence
		/// </summary>
		public UInt16 seq;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_CURRENT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request the overall list of mission items from the system/component.
	/// </summary>
	public class Msg_mission_request_list : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_REQUEST_LIST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of waypoints.
	/// </summary>
	public class Msg_mission_count : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Number of mission items in the sequence
		/// </summary>
		public UInt16 count;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_COUNT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Delete all mission items at once.
	/// </summary>
	public class Msg_mission_clear_all : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_CLEAR_ALL(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next waypoint.
	/// </summary>
	public class Msg_mission_item_reached : MavlinkMessage
    {

		/// <summary>
		/// Sequence
		/// </summary>
		public UInt16 seq;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_ITEM_REACHED(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Acknowledgment message during waypoint handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero).
	/// </summary>
	public class Msg_mission_ack : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Mission result.
		/// </summary>
		public byte type;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_ACK(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sets the GPS co-ordinates of the vehicle local origin (0,0,0) position. Vehicle should emit GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the local coordinate frame and the global (GPS) coordinate frame, which may be necessary when (for example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor.
	/// </summary>
	public class Msg_set_gps_global_origin : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 latitude;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 longitude;

		/// <summary>
		/// Altitude (MSL). Positive for up.
		/// </summary>
		public Int32 altitude;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SET_GPS_GLOBAL_ORIGIN(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Publishes the GPS co-ordinates of the vehicle local origin (0,0,0) position. Emitted whenever a new GPS-Local position mapping is requested or set - e.g. following SET_GPS_GLOBAL_ORIGIN message.
	/// </summary>
	public class Msg_gps_global_origin : MavlinkMessage
    {

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 latitude;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 longitude;

		/// <summary>
		/// Altitude (MSL). Positive for up.
		/// </summary>
		public Int32 altitude;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS_GLOBAL_ORIGIN(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Bind a RC channel to a parameter. The parameter should change according to the RC channel value.
	/// </summary>
	public class Msg_param_map_rc : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
		/// </summary>
		public byte[] param_id; // Array size 16

		/// <summary>
		/// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
		/// </summary>
		public Int16 param_index;

		/// <summary>
		/// Index of parameter RC channel. Not equal to the RC channel id. Typically corresponds to a potentiometer-knob on the RC.
		/// </summary>
		public byte parameter_rc_channel_index;

		/// <summary>
		/// Initial parameter value
		/// </summary>
		public float param_value0;

		/// <summary>
		/// Scale, maps the RC range [-1, 1] to a parameter value
		/// </summary>
		public float scale;

		/// <summary>
		/// Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
		/// </summary>
		public float param_value_min;

		/// <summary>
		/// Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
		/// </summary>
		public float param_value_max;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_PARAM_MAP_RC(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. https://mavlink.io/en/services/mission.html
	/// </summary>
	public class Msg_mission_request_int : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Sequence
		/// </summary>
		public UInt16 seq;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_REQUEST_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// A broadcast message to notify any ground station or SDK if a mission, geofence or safe points have changed on the vehicle.
	/// </summary>
	public class Msg_mission_changed : MavlinkMessage
    {

		/// <summary>
		/// Start index for partial mission change (-1 for all items).
		/// </summary>
		public Int16 start_index;

		/// <summary>
		/// End index of a partial mission change. -1 is a synonym for the last mission item (i.e. selects all items from start_index). Ignore field if start_index=-1.
		/// </summary>
		public Int16 end_index;

		/// <summary>
		/// System ID of the author of the new mission.
		/// </summary>
		public byte origin_sysid;

		/// <summary>
		/// Compnent ID of the author of the new mission.
		/// </summary>
		public byte origin_compid;

		/// <summary>
		/// Mission type.
		/// </summary>
		public byte mission_type;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_CHANGED(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national or competition regulations.
	/// </summary>
	public class Msg_safety_set_allowed_area : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
		/// </summary>
		public byte frame;

		/// <summary>
		/// x position 1 / Latitude 1
		/// </summary>
		public float p1x;

		/// <summary>
		/// y position 1 / Longitude 1
		/// </summary>
		public float p1y;

		/// <summary>
		/// z position 1 / Altitude 1
		/// </summary>
		public float p1z;

		/// <summary>
		/// x position 2 / Latitude 2
		/// </summary>
		public float p2x;

		/// <summary>
		/// y position 2 / Longitude 2
		/// </summary>
		public float p2y;

		/// <summary>
		/// z position 2 / Altitude 2
		/// </summary>
		public float p2z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SAFETY_SET_ALLOWED_AREA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Read out the safety zone the MAV currently assumes.
	/// </summary>
	public class Msg_safety_allowed_area : MavlinkMessage
    {

		/// <summary>
		/// Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
		/// </summary>
		public byte frame;

		/// <summary>
		/// x position 1 / Latitude 1
		/// </summary>
		public float p1x;

		/// <summary>
		/// y position 1 / Longitude 1
		/// </summary>
		public float p1y;

		/// <summary>
		/// z position 1 / Altitude 1
		/// </summary>
		public float p1z;

		/// <summary>
		/// x position 2 / Latitude 2
		/// </summary>
		public float p2x;

		/// <summary>
		/// y position 2 / Longitude 2
		/// </summary>
		public float p2y;

		/// <summary>
		/// z position 2 / Altitude 2
		/// </summary>
		public float p2z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SAFETY_ALLOWED_AREA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
	/// </summary>
	public class Msg_attitude_quaternion_cov : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
		/// </summary>
		public float[] q; // Array size 4

		/// <summary>
		/// Roll angular speed
		/// </summary>
		public float rollspeed;

		/// <summary>
		/// Pitch angular speed
		/// </summary>
		public float pitchspeed;

		/// <summary>
		/// Yaw angular speed
		/// </summary>
		public float yawspeed;

		/// <summary>
		/// Row-major representation of a 3x3 attitude covariance matrix (states: roll, pitch, yaw; first three entries are the first ROW, next three entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
		/// </summary>
		public float[] covariance; // Array size 9

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ATTITUDE_QUATERNION_COV(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The state of the fixed wing navigation and position controller.
	/// </summary>
	public class Msg_nav_controller_output : MavlinkMessage
    {

		/// <summary>
		/// Current desired roll
		/// </summary>
		public float nav_roll;

		/// <summary>
		/// Current desired pitch
		/// </summary>
		public float nav_pitch;

		/// <summary>
		/// Current desired heading
		/// </summary>
		public Int16 nav_bearing;

		/// <summary>
		/// Bearing to current waypoint/target
		/// </summary>
		public Int16 target_bearing;

		/// <summary>
		/// Distance to active waypoint
		/// </summary>
		public UInt16 wp_dist;

		/// <summary>
		/// Current altitude error
		/// </summary>
		public float alt_error;

		/// <summary>
		/// Current airspeed error
		/// </summary>
		public float aspd_error;

		/// <summary>
		/// Current crosstrack error on x-y plane
		/// </summary>
		public float xtrack_error;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_NAV_CONTROLLER_OUTPUT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset.
	/// </summary>
	public class Msg_global_position_int_cov : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Class id of the estimator this estimate originated from.
		/// </summary>
		public byte estimator_type;

		/// <summary>
		/// Latitude
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude in meters above MSL
		/// </summary>
		public Int32 alt;

		/// <summary>
		/// Altitude above ground
		/// </summary>
		public Int32 relative_alt;

		/// <summary>
		/// Ground X Speed (Latitude)
		/// </summary>
		public float vx;

		/// <summary>
		/// Ground Y Speed (Longitude)
		/// </summary>
		public float vy;

		/// <summary>
		/// Ground Z Speed (Altitude)
		/// </summary>
		public float vz;

		/// <summary>
		/// Row-major representation of a 6x6 position and velocity 6x6 cross-covariance matrix (states: lat, lon, alt, vx, vy, vz; first six entries are the first ROW, next six entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
		/// </summary>
		public float[] covariance; // Array size 36

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GLOBAL_POSITION_INT_COV(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
	/// </summary>
	public class Msg_local_position_ned_cov : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Class id of the estimator this estimate originated from.
		/// </summary>
		public byte estimator_type;

		/// <summary>
		/// X Position
		/// </summary>
		public float x;

		/// <summary>
		/// Y Position
		/// </summary>
		public float y;

		/// <summary>
		/// Z Position
		/// </summary>
		public float z;

		/// <summary>
		/// X Speed
		/// </summary>
		public float vx;

		/// <summary>
		/// Y Speed
		/// </summary>
		public float vy;

		/// <summary>
		/// Z Speed
		/// </summary>
		public float vz;

		/// <summary>
		/// X Acceleration
		/// </summary>
		public float ax;

		/// <summary>
		/// Y Acceleration
		/// </summary>
		public float ay;

		/// <summary>
		/// Z Acceleration
		/// </summary>
		public float az;

		/// <summary>
		/// Row-major representation of position, velocity and acceleration 9x9 cross-covariance matrix upper right triangle (states: x, y, z, vx, vy, vz, ax, ay, az; first nine entries are the first ROW, next eight entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
		/// </summary>
		public float[] covariance; // Array size 45

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOCAL_POSITION_NED_COV(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.  A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
	/// </summary>
	public class Msg_rc_channels : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
		/// </summary>
		public byte chancount;

		/// <summary>
		/// RC channel 1 value.
		/// </summary>
		public UInt16 chan1_raw;

		/// <summary>
		/// RC channel 2 value.
		/// </summary>
		public UInt16 chan2_raw;

		/// <summary>
		/// RC channel 3 value.
		/// </summary>
		public UInt16 chan3_raw;

		/// <summary>
		/// RC channel 4 value.
		/// </summary>
		public UInt16 chan4_raw;

		/// <summary>
		/// RC channel 5 value.
		/// </summary>
		public UInt16 chan5_raw;

		/// <summary>
		/// RC channel 6 value.
		/// </summary>
		public UInt16 chan6_raw;

		/// <summary>
		/// RC channel 7 value.
		/// </summary>
		public UInt16 chan7_raw;

		/// <summary>
		/// RC channel 8 value.
		/// </summary>
		public UInt16 chan8_raw;

		/// <summary>
		/// RC channel 9 value.
		/// </summary>
		public UInt16 chan9_raw;

		/// <summary>
		/// RC channel 10 value.
		/// </summary>
		public UInt16 chan10_raw;

		/// <summary>
		/// RC channel 11 value.
		/// </summary>
		public UInt16 chan11_raw;

		/// <summary>
		/// RC channel 12 value.
		/// </summary>
		public UInt16 chan12_raw;

		/// <summary>
		/// RC channel 13 value.
		/// </summary>
		public UInt16 chan13_raw;

		/// <summary>
		/// RC channel 14 value.
		/// </summary>
		public UInt16 chan14_raw;

		/// <summary>
		/// RC channel 15 value.
		/// </summary>
		public UInt16 chan15_raw;

		/// <summary>
		/// RC channel 16 value.
		/// </summary>
		public UInt16 chan16_raw;

		/// <summary>
		/// RC channel 17 value.
		/// </summary>
		public UInt16 chan17_raw;

		/// <summary>
		/// RC channel 18 value.
		/// </summary>
		public UInt16 chan18_raw;

		/// <summary>
		/// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte rssi;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RC_CHANNELS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request a data stream.
	/// </summary>
	public class Msg_request_data_stream : MavlinkMessage
    {

		/// <summary>
		/// The target requested to send the message stream.
		/// </summary>
		public byte target_system;

		/// <summary>
		/// The target requested to send the message stream.
		/// </summary>
		public byte target_component;

		/// <summary>
		/// The ID of the requested data stream
		/// </summary>
		public byte req_stream_id;

		/// <summary>
		/// The requested message rate
		/// </summary>
		public UInt16 req_message_rate;

		/// <summary>
		/// 1 to start sending, 0 to stop sending.
		/// </summary>
		public byte start_stop;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_REQUEST_DATA_STREAM(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Data stream status information.
	/// </summary>
	public class Msg_data_stream : MavlinkMessage
    {

		/// <summary>
		/// The ID of the requested data stream
		/// </summary>
		public byte stream_id;

		/// <summary>
		/// The message rate
		/// </summary>
		public UInt16 message_rate;

		/// <summary>
		/// 1 stream is enabled, 0 stream is stopped.
		/// </summary>
		public byte on_off;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_DATA_STREAM(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled an buttons are also transmit as boolean values of their 
	/// </summary>
	public class Msg_manual_control : MavlinkMessage
    {

		/// <summary>
		/// The system to be controlled.
		/// </summary>
		public byte target;

		/// <summary>
		/// X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
		/// </summary>
		public Int16 x;

		/// <summary>
		/// Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
		/// </summary>
		public Int16 y;

		/// <summary>
		/// Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust.
		/// </summary>
		public Int16 z;

		/// <summary>
		/// R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
		/// </summary>
		public Int16 r;

		/// <summary>
		/// A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
		/// </summary>
		public UInt16 buttons;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MANUAL_CONTROL(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The RAW values of the RC channels sent to the MAV to override info received from the RC radio. A value of UINT16_MAX means no change to that channel. A value of 0 means control of that channel should be released back to the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
	/// </summary>
	public class Msg_rc_channels_override : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// RC channel 1 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan1_raw;

		/// <summary>
		/// RC channel 2 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan2_raw;

		/// <summary>
		/// RC channel 3 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan3_raw;

		/// <summary>
		/// RC channel 4 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan4_raw;

		/// <summary>
		/// RC channel 5 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan5_raw;

		/// <summary>
		/// RC channel 6 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan6_raw;

		/// <summary>
		/// RC channel 7 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan7_raw;

		/// <summary>
		/// RC channel 8 value. A value of UINT16_MAX means to ignore this field.
		/// </summary>
		public UInt16 chan8_raw;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RC_CHANNELS_OVERRIDE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Message encoding a mission item. This message is emitted to announce
	///                the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
	/// </summary>
	public class Msg_mission_item_int : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
		/// </summary>
		public UInt16 seq;

		/// <summary>
		/// The coordinate system of the waypoint.
		/// </summary>
		public byte frame;

		/// <summary>
		/// The scheduled action for the waypoint.
		/// </summary>
		public UInt16 command;

		/// <summary>
		/// false:0, true:1
		/// </summary>
		public byte current;

		/// <summary>
		/// Autocontinue to next waypoint
		/// </summary>
		public byte autocontinue;

		/// <summary>
		/// PARAM1, see MAV_CMD enum
		/// </summary>
		public float param1;

		/// <summary>
		/// PARAM2, see MAV_CMD enum
		/// </summary>
		public float param2;

		/// <summary>
		/// PARAM3, see MAV_CMD enum
		/// </summary>
		public float param3;

		/// <summary>
		/// PARAM4, see MAV_CMD enum
		/// </summary>
		public float param4;

		/// <summary>
		/// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
		/// </summary>
		public Int32 x;

		/// <summary>
		/// PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
		/// </summary>
		public Int32 y;

		/// <summary>
		/// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
		/// </summary>
		public float z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MISSION_ITEM_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Metrics typically displayed on a HUD for fixed wing aircraft.
	/// </summary>
	public class Msg_vfr_hud : MavlinkMessage
    {

		/// <summary>
		/// Vehicle speed in form appropriate for vehicle type. For standard aircraft this is typically calibrated airspeed (CAS) or indicated airspeed (IAS) - either of which can be used by a pilot to estimate stall speed.
		/// </summary>
		public float airspeed;

		/// <summary>
		/// Current ground speed.
		/// </summary>
		public float groundspeed;

		/// <summary>
		/// Current heading in compass units (0-360, 0=north).
		/// </summary>
		public Int16 heading;

		/// <summary>
		/// Current throttle setting (0 to 100).
		/// </summary>
		public UInt16 throttle;

		/// <summary>
		/// Current altitude (MSL).
		/// </summary>
		public float alt;

		/// <summary>
		/// Current climb rate.
		/// </summary>
		public float climb;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_VFR_HUD(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value. The command microservice is documented at https://mavlink.io/en/services/command.html
	/// </summary>
	public class Msg_command_int : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// The coordinate system of the COMMAND.
		/// </summary>
		public byte frame;

		/// <summary>
		/// The scheduled action for the mission item.
		/// </summary>
		public UInt16 command;

		/// <summary>
		/// false:0, true:1
		/// </summary>
		public byte current;

		/// <summary>
		/// autocontinue to next wp
		/// </summary>
		public byte autocontinue;

		/// <summary>
		/// PARAM1, see MAV_CMD enum
		/// </summary>
		public float param1;

		/// <summary>
		/// PARAM2, see MAV_CMD enum
		/// </summary>
		public float param2;

		/// <summary>
		/// PARAM3, see MAV_CMD enum
		/// </summary>
		public float param3;

		/// <summary>
		/// PARAM4, see MAV_CMD enum
		/// </summary>
		public float param4;

		/// <summary>
		/// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
		/// </summary>
		public Int32 x;

		/// <summary>
		/// PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
		/// </summary>
		public Int32 y;

		/// <summary>
		/// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame).
		/// </summary>
		public float z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_COMMAND_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Send a command with up to seven parameters to the MAV. The command microservice is documented at https://mavlink.io/en/services/command.html
	/// </summary>
	public class Msg_command_long : MavlinkMessage
    {

		/// <summary>
		/// System which should execute the command
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component which should execute the command, 0 for all components
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Command ID (of command to send).
		/// </summary>
		public UInt16 command;

		/// <summary>
		/// 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
		/// </summary>
		public byte confirmation;

		/// <summary>
		/// Parameter 1 (for the specific command).
		/// </summary>
		public float param1;

		/// <summary>
		/// Parameter 2 (for the specific command).
		/// </summary>
		public float param2;

		/// <summary>
		/// Parameter 3 (for the specific command).
		/// </summary>
		public float param3;

		/// <summary>
		/// Parameter 4 (for the specific command).
		/// </summary>
		public float param4;

		/// <summary>
		/// Parameter 5 (for the specific command).
		/// </summary>
		public float param5;

		/// <summary>
		/// Parameter 6 (for the specific command).
		/// </summary>
		public float param6;

		/// <summary>
		/// Parameter 7 (for the specific command).
		/// </summary>
		public float param7;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_COMMAND_LONG(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Report status of a command. Includes feedback whether the command was executed. The command microservice is documented at https://mavlink.io/en/services/command.html
	/// </summary>
	public class Msg_command_ack : MavlinkMessage
    {

		/// <summary>
		/// Command ID (of acknowledged command).
		/// </summary>
		public UInt16 command;

		/// <summary>
		/// Result of command.
		/// </summary>
		public byte result;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_COMMAND_ACK(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Cancel a long running command. The target system should respond with a COMMAND_ACK to the original command with result=MAV_RESULT_CANCELLED if the long running process was cancelled. If it has already completed, the cancel action can be ignored. The cancel action can be retried until some sort of acknowledgement to the original command has been received. The command microservice is documented at https://mavlink.io/en/services/command.html
	/// </summary>
	public class Msg_command_cancel : MavlinkMessage
    {

		/// <summary>
		/// System executing long running command. Should not be broadcast (0).
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component executing long running command.
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Command ID (of command to cancel).
		/// </summary>
		public UInt16 command;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_COMMAND_CANCEL(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Setpoint in roll, pitch, yaw and thrust from the operator
	/// </summary>
	public class Msg_manual_setpoint : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Desired roll rate
		/// </summary>
		public float roll;

		/// <summary>
		/// Desired pitch rate
		/// </summary>
		public float pitch;

		/// <summary>
		/// Desired yaw rate
		/// </summary>
		public float yaw;

		/// <summary>
		/// Collective thrust, normalized to 0 .. 1
		/// </summary>
		public float thrust;

		/// <summary>
		/// Flight mode switch position, 0.. 255
		/// </summary>
		public byte mode_switch;

		/// <summary>
		/// Override mode switch position, 0.. 255
		/// </summary>
		public byte manual_override_switch;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MANUAL_SETPOINT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system).
	/// </summary>
	public class Msg_set_attitude_target : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
		/// </summary>
		public byte type_mask;

		/// <summary>
		/// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
		/// </summary>
		public float[] q; // Array size 4

		/// <summary>
		/// Body roll rate
		/// </summary>
		public float body_roll_rate;

		/// <summary>
		/// Body pitch rate
		/// </summary>
		public float body_pitch_rate;

		/// <summary>
		/// Body yaw rate
		/// </summary>
		public float body_yaw_rate;

		/// <summary>
		/// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
		/// </summary>
		public float thrust;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SET_ATTITUDE_TARGET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way.
	/// </summary>
	public class Msg_attitude_target : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
		/// </summary>
		public byte type_mask;

		/// <summary>
		/// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
		/// </summary>
		public float[] q; // Array size 4

		/// <summary>
		/// Body roll rate
		/// </summary>
		public float body_roll_rate;

		/// <summary>
		/// Body pitch rate
		/// </summary>
		public float body_pitch_rate;

		/// <summary>
		/// Body yaw rate
		/// </summary>
		public float body_yaw_rate;

		/// <summary>
		/// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
		/// </summary>
		public float thrust;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ATTITUDE_TARGET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system).
	/// </summary>
	public class Msg_set_position_target_local_ned : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
		/// </summary>
		public byte coordinate_frame;

		/// <summary>
		/// Bitmap to indicate which dimensions should be ignored by the vehicle.
		/// </summary>
		public UInt16 type_mask;

		/// <summary>
		/// X Position in NED frame
		/// </summary>
		public float x;

		/// <summary>
		/// Y Position in NED frame
		/// </summary>
		public float y;

		/// <summary>
		/// Z Position in NED frame (note, altitude is negative in NED)
		/// </summary>
		public float z;

		/// <summary>
		/// X velocity in NED frame
		/// </summary>
		public float vx;

		/// <summary>
		/// Y velocity in NED frame
		/// </summary>
		public float vy;

		/// <summary>
		/// Z velocity in NED frame
		/// </summary>
		public float vz;

		/// <summary>
		/// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afx;

		/// <summary>
		/// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afy;

		/// <summary>
		/// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afz;

		/// <summary>
		/// yaw setpoint
		/// </summary>
		public float yaw;

		/// <summary>
		/// yaw rate setpoint
		/// </summary>
		public float yaw_rate;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SET_POSITION_TARGET_LOCAL_NED(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way.
	/// </summary>
	public class Msg_position_target_local_ned : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
		/// </summary>
		public byte coordinate_frame;

		/// <summary>
		/// Bitmap to indicate which dimensions should be ignored by the vehicle.
		/// </summary>
		public UInt16 type_mask;

		/// <summary>
		/// X Position in NED frame
		/// </summary>
		public float x;

		/// <summary>
		/// Y Position in NED frame
		/// </summary>
		public float y;

		/// <summary>
		/// Z Position in NED frame (note, altitude is negative in NED)
		/// </summary>
		public float z;

		/// <summary>
		/// X velocity in NED frame
		/// </summary>
		public float vx;

		/// <summary>
		/// Y velocity in NED frame
		/// </summary>
		public float vy;

		/// <summary>
		/// Z velocity in NED frame
		/// </summary>
		public float vz;

		/// <summary>
		/// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afx;

		/// <summary>
		/// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afy;

		/// <summary>
		/// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afz;

		/// <summary>
		/// yaw setpoint
		/// </summary>
		public float yaw;

		/// <summary>
		/// yaw rate setpoint
		/// </summary>
		public float yaw_rate;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_POSITION_TARGET_LOCAL_NED(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system).
	/// </summary>
	public class Msg_set_position_target_global_int : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
		/// </summary>
		public byte coordinate_frame;

		/// <summary>
		/// Bitmap to indicate which dimensions should be ignored by the vehicle.
		/// </summary>
		public UInt16 type_mask;

		/// <summary>
		/// X Position in WGS84 frame
		/// </summary>
		public Int32 lat_int;

		/// <summary>
		/// Y Position in WGS84 frame
		/// </summary>
		public Int32 lon_int;

		/// <summary>
		/// Altitude (MSL, Relative to home, or AGL - depending on frame)
		/// </summary>
		public float alt;

		/// <summary>
		/// X velocity in NED frame
		/// </summary>
		public float vx;

		/// <summary>
		/// Y velocity in NED frame
		/// </summary>
		public float vy;

		/// <summary>
		/// Z velocity in NED frame
		/// </summary>
		public float vz;

		/// <summary>
		/// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afx;

		/// <summary>
		/// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afy;

		/// <summary>
		/// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afz;

		/// <summary>
		/// yaw setpoint
		/// </summary>
		public float yaw;

		/// <summary>
		/// yaw rate setpoint
		/// </summary>
		public float yaw_rate;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SET_POSITION_TARGET_GLOBAL_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way.
	/// </summary>
	public class Msg_position_target_global_int : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
		/// </summary>
		public byte coordinate_frame;

		/// <summary>
		/// Bitmap to indicate which dimensions should be ignored by the vehicle.
		/// </summary>
		public UInt16 type_mask;

		/// <summary>
		/// X Position in WGS84 frame
		/// </summary>
		public Int32 lat_int;

		/// <summary>
		/// Y Position in WGS84 frame
		/// </summary>
		public Int32 lon_int;

		/// <summary>
		/// Altitude (MSL, AGL or relative to home altitude, depending on frame)
		/// </summary>
		public float alt;

		/// <summary>
		/// X velocity in NED frame
		/// </summary>
		public float vx;

		/// <summary>
		/// Y velocity in NED frame
		/// </summary>
		public float vy;

		/// <summary>
		/// Z velocity in NED frame
		/// </summary>
		public float vz;

		/// <summary>
		/// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afx;

		/// <summary>
		/// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afy;

		/// <summary>
		/// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
		/// </summary>
		public float afz;

		/// <summary>
		/// yaw setpoint
		/// </summary>
		public float yaw;

		/// <summary>
		/// yaw rate setpoint
		/// </summary>
		public float yaw_rate;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_POSITION_TARGET_GLOBAL_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
	/// </summary>
	public class Msg_local_position_ned_system_global_offset : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// X Position
		/// </summary>
		public float x;

		/// <summary>
		/// Y Position
		/// </summary>
		public float y;

		/// <summary>
		/// Z Position
		/// </summary>
		public float z;
		public float roll;
		public float pitch;
		public float yaw;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations.
	/// </summary>
	public class Msg_hil_state : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Roll angle
		/// </summary>
		public float roll;

		/// <summary>
		/// Pitch angle
		/// </summary>
		public float pitch;

		/// <summary>
		/// Yaw angle
		/// </summary>
		public float yaw;

		/// <summary>
		/// Body frame roll / phi angular speed
		/// </summary>
		public float rollspeed;

		/// <summary>
		/// Body frame pitch / theta angular speed
		/// </summary>
		public float pitchspeed;

		/// <summary>
		/// Body frame yaw / psi angular speed
		/// </summary>
		public float yawspeed;

		/// <summary>
		/// Latitude
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude
		/// </summary>
		public Int32 alt;

		/// <summary>
		/// Ground X Speed (Latitude)
		/// </summary>
		public Int16 vx;

		/// <summary>
		/// Ground Y Speed (Longitude)
		/// </summary>
		public Int16 vy;

		/// <summary>
		/// Ground Z Speed (Altitude)
		/// </summary>
		public Int16 vz;

		/// <summary>
		/// X acceleration
		/// </summary>
		public Int16 xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public Int16 yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public Int16 zacc;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_STATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sent from autopilot to simulation. Hardware in the loop control outputs
	/// </summary>
	public class Msg_hil_controls : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Control output -1 .. 1
		/// </summary>
		public float roll_ailerons;

		/// <summary>
		/// Control output -1 .. 1
		/// </summary>
		public float pitch_elevator;

		/// <summary>
		/// Control output -1 .. 1
		/// </summary>
		public float yaw_rudder;

		/// <summary>
		/// Throttle 0 .. 1
		/// </summary>
		public float throttle;

		/// <summary>
		/// Aux 1, -1 .. 1
		/// </summary>
		public float aux1;

		/// <summary>
		/// Aux 2, -1 .. 1
		/// </summary>
		public float aux2;

		/// <summary>
		/// Aux 3, -1 .. 1
		/// </summary>
		public float aux3;

		/// <summary>
		/// Aux 4, -1 .. 1
		/// </summary>
		public float aux4;

		/// <summary>
		/// System mode.
		/// </summary>
		public byte mode;

		/// <summary>
		/// Navigation mode (MAV_NAV_MODE)
		/// </summary>
		public byte nav_mode;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_CONTROLS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
	/// </summary>
	public class Msg_hil_rc_inputs_raw : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// RC channel 1 value
		/// </summary>
		public UInt16 chan1_raw;

		/// <summary>
		/// RC channel 2 value
		/// </summary>
		public UInt16 chan2_raw;

		/// <summary>
		/// RC channel 3 value
		/// </summary>
		public UInt16 chan3_raw;

		/// <summary>
		/// RC channel 4 value
		/// </summary>
		public UInt16 chan4_raw;

		/// <summary>
		/// RC channel 5 value
		/// </summary>
		public UInt16 chan5_raw;

		/// <summary>
		/// RC channel 6 value
		/// </summary>
		public UInt16 chan6_raw;

		/// <summary>
		/// RC channel 7 value
		/// </summary>
		public UInt16 chan7_raw;

		/// <summary>
		/// RC channel 8 value
		/// </summary>
		public UInt16 chan8_raw;

		/// <summary>
		/// RC channel 9 value
		/// </summary>
		public UInt16 chan9_raw;

		/// <summary>
		/// RC channel 10 value
		/// </summary>
		public UInt16 chan10_raw;

		/// <summary>
		/// RC channel 11 value
		/// </summary>
		public UInt16 chan11_raw;

		/// <summary>
		/// RC channel 12 value
		/// </summary>
		public UInt16 chan12_raw;

		/// <summary>
		/// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte rssi;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_RC_INPUTS_RAW(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS)
	/// </summary>
	public class Msg_hil_actuator_controls : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.
		/// </summary>
		public float[] controls; // Array size 16

		/// <summary>
		/// System mode. Includes arming state.
		/// </summary>
		public byte mode;

		/// <summary>
		/// Flags as bitfield, 1: indicate simulation using lockstep.
		/// </summary>
		public UInt64 flags;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_ACTUATOR_CONTROLS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Optical flow from a flow sensor (e.g. optical mouse sensor)
	/// </summary>
	public class Msg_optical_flow : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Sensor ID
		/// </summary>
		public byte sensor_id;

		/// <summary>
		/// Flow in x-sensor direction
		/// </summary>
		public Int16 flow_x;

		/// <summary>
		/// Flow in y-sensor direction
		/// </summary>
		public Int16 flow_y;

		/// <summary>
		/// Flow in x-sensor direction, angular-speed compensated
		/// </summary>
		public float flow_comp_m_x;

		/// <summary>
		/// Flow in y-sensor direction, angular-speed compensated
		/// </summary>
		public float flow_comp_m_y;

		/// <summary>
		/// Optical flow quality / confidence. 0: bad, 255: maximum quality
		/// </summary>
		public byte quality;

		/// <summary>
		/// Ground distance. Positive value: distance known. Negative value: Unknown distance
		/// </summary>
		public float ground_distance;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_OPTICAL_FLOW(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Global position/attitude estimate from a vision source.
	/// </summary>
	public class Msg_global_vision_position_estimate : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX time or since system boot)
		/// </summary>
		public UInt64 usec;

		/// <summary>
		/// Global X position
		/// </summary>
		public float x;

		/// <summary>
		/// Global Y position
		/// </summary>
		public float y;

		/// <summary>
		/// Global Z position
		/// </summary>
		public float z;

		/// <summary>
		/// Roll angle
		/// </summary>
		public float roll;

		/// <summary>
		/// Pitch angle
		/// </summary>
		public float pitch;

		/// <summary>
		/// Yaw angle
		/// </summary>
		public float yaw;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GLOBAL_VISION_POSITION_ESTIMATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Local position/attitude estimate from a vision source.
	/// </summary>
	public class Msg_vision_position_estimate : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX time or time since system boot)
		/// </summary>
		public UInt64 usec;

		/// <summary>
		/// Local X position
		/// </summary>
		public float x;

		/// <summary>
		/// Local Y position
		/// </summary>
		public float y;

		/// <summary>
		/// Local Z position
		/// </summary>
		public float z;

		/// <summary>
		/// Roll angle
		/// </summary>
		public float roll;

		/// <summary>
		/// Pitch angle
		/// </summary>
		public float pitch;

		/// <summary>
		/// Yaw angle
		/// </summary>
		public float yaw;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_VISION_POSITION_ESTIMATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Speed estimate from a vision source.
	/// </summary>
	public class Msg_vision_speed_estimate : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX time or time since system boot)
		/// </summary>
		public UInt64 usec;

		/// <summary>
		/// Global X speed
		/// </summary>
		public float x;

		/// <summary>
		/// Global Y speed
		/// </summary>
		public float y;

		/// <summary>
		/// Global Z speed
		/// </summary>
		public float z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_VISION_SPEED_ESTIMATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Global position estimate from a Vicon motion system source.
	/// </summary>
	public class Msg_vicon_position_estimate : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX time or time since system boot)
		/// </summary>
		public UInt64 usec;

		/// <summary>
		/// Global X position
		/// </summary>
		public float x;

		/// <summary>
		/// Global Y position
		/// </summary>
		public float y;

		/// <summary>
		/// Global Z position
		/// </summary>
		public float z;

		/// <summary>
		/// Roll angle
		/// </summary>
		public float roll;

		/// <summary>
		/// Pitch angle
		/// </summary>
		public float pitch;

		/// <summary>
		/// Yaw angle
		/// </summary>
		public float yaw;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_VICON_POSITION_ESTIMATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The IMU readings in SI units in NED body frame
	/// </summary>
	public class Msg_highres_imu : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// X acceleration
		/// </summary>
		public float xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public float yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public float zacc;

		/// <summary>
		/// Angular speed around X axis
		/// </summary>
		public float xgyro;

		/// <summary>
		/// Angular speed around Y axis
		/// </summary>
		public float ygyro;

		/// <summary>
		/// Angular speed around Z axis
		/// </summary>
		public float zgyro;

		/// <summary>
		/// X Magnetic field
		/// </summary>
		public float xmag;

		/// <summary>
		/// Y Magnetic field
		/// </summary>
		public float ymag;

		/// <summary>
		/// Z Magnetic field
		/// </summary>
		public float zmag;

		/// <summary>
		/// Absolute pressure
		/// </summary>
		public float abs_pressure;

		/// <summary>
		/// Differential pressure
		/// </summary>
		public float diff_pressure;

		/// <summary>
		/// Altitude calculated from pressure
		/// </summary>
		public float pressure_alt;
		public float temperature;

		/// <summary>
		/// Bitmap for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
		/// </summary>
		public UInt16 fields_updated;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIGHRES_IMU(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)
	/// </summary>
	public class Msg_optical_flow_rad : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Sensor ID
		/// </summary>
		public byte sensor_id;

		/// <summary>
		/// Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
		/// </summary>
		public UInt32 integration_time_us;

		/// <summary>
		/// Flow around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
		/// </summary>
		public float integrated_x;

		/// <summary>
		/// Flow around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
		/// </summary>
		public float integrated_y;

		/// <summary>
		/// RH rotation around X axis
		/// </summary>
		public float integrated_xgyro;

		/// <summary>
		/// RH rotation around Y axis
		/// </summary>
		public float integrated_ygyro;

		/// <summary>
		/// RH rotation around Z axis
		/// </summary>
		public float integrated_zgyro;
		public Int16 temperature;

		/// <summary>
		/// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
		/// </summary>
		public byte quality;

		/// <summary>
		/// Time since the distance was sampled.
		/// </summary>
		public UInt32 time_delta_distance_us;

		/// <summary>
		/// Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.
		/// </summary>
		public float distance;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_OPTICAL_FLOW_RAD(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The IMU readings in SI units in NED body frame
	/// </summary>
	public class Msg_hil_sensor : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// X acceleration
		/// </summary>
		public float xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public float yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public float zacc;

		/// <summary>
		/// Angular speed around X axis in body frame
		/// </summary>
		public float xgyro;

		/// <summary>
		/// Angular speed around Y axis in body frame
		/// </summary>
		public float ygyro;

		/// <summary>
		/// Angular speed around Z axis in body frame
		/// </summary>
		public float zgyro;

		/// <summary>
		/// X Magnetic field
		/// </summary>
		public float xmag;

		/// <summary>
		/// Y Magnetic field
		/// </summary>
		public float ymag;

		/// <summary>
		/// Z Magnetic field
		/// </summary>
		public float zmag;

		/// <summary>
		/// Absolute pressure
		/// </summary>
		public float abs_pressure;

		/// <summary>
		/// Differential pressure (airspeed)
		/// </summary>
		public float diff_pressure;

		/// <summary>
		/// Altitude calculated from pressure
		/// </summary>
		public float pressure_alt;
		public float temperature;

		/// <summary>
		/// Bitmap for fields that have updated since last message, bit 0 = xacc, bit 12: temperature, bit 31: full reset of attitude/position/velocities/etc was performed in sim.
		/// </summary>
		public UInt32 fields_updated;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_SENSOR(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Status of simulation environment, if used
	/// </summary>
	public class Msg_sim_state : MavlinkMessage
    {

		/// <summary>
		/// True attitude quaternion component 1, w (1 in null-rotation)
		/// </summary>
		public float q1;

		/// <summary>
		/// True attitude quaternion component 2, x (0 in null-rotation)
		/// </summary>
		public float q2;

		/// <summary>
		/// True attitude quaternion component 3, y (0 in null-rotation)
		/// </summary>
		public float q3;

		/// <summary>
		/// True attitude quaternion component 4, z (0 in null-rotation)
		/// </summary>
		public float q4;

		/// <summary>
		/// Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
		/// </summary>
		public float roll;

		/// <summary>
		/// Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
		/// </summary>
		public float pitch;

		/// <summary>
		/// Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
		/// </summary>
		public float yaw;

		/// <summary>
		/// X acceleration
		/// </summary>
		public float xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public float yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public float zacc;

		/// <summary>
		/// Angular speed around X axis
		/// </summary>
		public float xgyro;

		/// <summary>
		/// Angular speed around Y axis
		/// </summary>
		public float ygyro;

		/// <summary>
		/// Angular speed around Z axis
		/// </summary>
		public float zgyro;

		/// <summary>
		/// Latitude
		/// </summary>
		public float lat;

		/// <summary>
		/// Longitude
		/// </summary>
		public float lon;

		/// <summary>
		/// Altitude
		/// </summary>
		public float alt;

		/// <summary>
		/// Horizontal position standard deviation
		/// </summary>
		public float std_dev_horz;

		/// <summary>
		/// Vertical position standard deviation
		/// </summary>
		public float std_dev_vert;

		/// <summary>
		/// True velocity in north direction in earth-fixed NED frame
		/// </summary>
		public float vn;

		/// <summary>
		/// True velocity in east direction in earth-fixed NED frame
		/// </summary>
		public float ve;

		/// <summary>
		/// True velocity in down direction in earth-fixed NED frame
		/// </summary>
		public float vd;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SIM_STATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Status generated by radio and injected into MAVLink stream.
	/// </summary>
	public class Msg_radio_status : MavlinkMessage
    {

		/// <summary>
		/// Local (message sender) recieved signal strength indication in device-dependent units/scale. Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte rssi;

		/// <summary>
		/// Remote (message receiver) signal strength indication in device-dependent units/scale. Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte remrssi;

		/// <summary>
		/// Remaining free transmitter buffer space.
		/// </summary>
		public byte txbuf;

		/// <summary>
		/// Local background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte noise;

		/// <summary>
		/// Remote background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], 255: invalid/unknown.
		/// </summary>
		public byte remnoise;

		/// <summary>
		/// Count of radio packet receive errors (since boot).
		/// </summary>
		public UInt16 rxerrors;

		/// <summary>
		/// Count of error corrected radio packets (since boot).
		/// </summary>
		public UInt16 @fixed;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RADIO_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// File transfer message
	/// </summary>
	public class Msg_file_transfer_protocol : MavlinkMessage
    {

		/// <summary>
		/// Network ID (0 for broadcast)
		/// </summary>
		public byte target_network;

		/// <summary>
		/// System ID (0 for broadcast)
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID (0 for broadcast)
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
		/// </summary>
		public byte[] payload; // Array size 251

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_FILE_TRANSFER_PROTOCOL(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Time synchronization message.
	/// </summary>
	public class Msg_timesync : MavlinkMessage
    {

		/// <summary>
		/// Time sync timestamp 1
		/// </summary>
		public Int64 tc1;

		/// <summary>
		/// Time sync timestamp 2
		/// </summary>
		public Int64 ts1;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_TIMESYNC(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Camera-IMU triggering and synchronisation message.
	/// </summary>
	public class Msg_camera_trigger : MavlinkMessage
    {

		/// <summary>
		/// Timestamp for image frame (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Image frame sequence
		/// </summary>
		public UInt32 seq;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_CAMERA_TRIGGER(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The global position, as returned by the Global Positioning System (GPS). This is
	///                 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate.
	/// </summary>
	public class Msg_hil_gps : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
		/// </summary>
		public byte fix_type;

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude (MSL). Positive for up.
		/// </summary>
		public Int32 alt;

		/// <summary>
		/// GPS HDOP horizontal dilution of position. If unknown, set to: 65535
		/// </summary>
		public UInt16 eph;

		/// <summary>
		/// GPS VDOP vertical dilution of position. If unknown, set to: 65535
		/// </summary>
		public UInt16 epv;

		/// <summary>
		/// GPS ground speed. If unknown, set to: 65535
		/// </summary>
		public UInt16 vel;

		/// <summary>
		/// GPS velocity in north direction in earth-fixed NED frame
		/// </summary>
		public Int16 vn;

		/// <summary>
		/// GPS velocity in east direction in earth-fixed NED frame
		/// </summary>
		public Int16 ve;

		/// <summary>
		/// GPS velocity in down direction in earth-fixed NED frame
		/// </summary>
		public Int16 vd;

		/// <summary>
		/// Course over ground (NOT heading, but direction of movement), 0.0..359.99 degrees. If unknown, set to: 65535
		/// </summary>
		public UInt16 cog;

		/// <summary>
		/// Number of satellites visible. If unknown, set to 255
		/// </summary>
		public byte satellites_visible;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_GPS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)
	/// </summary>
	public class Msg_hil_optical_flow : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Sensor ID
		/// </summary>
		public byte sensor_id;

		/// <summary>
		/// Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
		/// </summary>
		public UInt32 integration_time_us;

		/// <summary>
		/// Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
		/// </summary>
		public float integrated_x;

		/// <summary>
		/// Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
		/// </summary>
		public float integrated_y;

		/// <summary>
		/// RH rotation around X axis
		/// </summary>
		public float integrated_xgyro;

		/// <summary>
		/// RH rotation around Y axis
		/// </summary>
		public float integrated_ygyro;

		/// <summary>
		/// RH rotation around Z axis
		/// </summary>
		public float integrated_zgyro;
		public Int16 temperature;

		/// <summary>
		/// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
		/// </summary>
		public byte quality;

		/// <summary>
		/// Time since the distance was sampled.
		/// </summary>
		public UInt32 time_delta_distance_us;

		/// <summary>
		/// Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.
		/// </summary>
		public float distance;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_OPTICAL_FLOW(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations.
	/// </summary>
	public class Msg_hil_state_quaternion : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
		/// </summary>
		public float[] attitude_quaternion; // Array size 4

		/// <summary>
		/// Body frame roll / phi angular speed
		/// </summary>
		public float rollspeed;

		/// <summary>
		/// Body frame pitch / theta angular speed
		/// </summary>
		public float pitchspeed;

		/// <summary>
		/// Body frame yaw / psi angular speed
		/// </summary>
		public float yawspeed;

		/// <summary>
		/// Latitude
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude
		/// </summary>
		public Int32 alt;

		/// <summary>
		/// Ground X Speed (Latitude)
		/// </summary>
		public Int16 vx;

		/// <summary>
		/// Ground Y Speed (Longitude)
		/// </summary>
		public Int16 vy;

		/// <summary>
		/// Ground Z Speed (Altitude)
		/// </summary>
		public Int16 vz;

		/// <summary>
		/// Indicated airspeed
		/// </summary>
		public UInt16 ind_airspeed;

		/// <summary>
		/// True airspeed
		/// </summary>
		public UInt16 true_airspeed;

		/// <summary>
		/// X acceleration
		/// </summary>
		public Int16 xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public Int16 yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public Int16 zacc;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIL_STATE_QUATERNION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units
	/// </summary>
	public class Msg_scaled_imu2 : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// X acceleration
		/// </summary>
		public Int16 xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public Int16 yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public Int16 zacc;

		/// <summary>
		/// Angular speed around X axis
		/// </summary>
		public Int16 xgyro;

		/// <summary>
		/// Angular speed around Y axis
		/// </summary>
		public Int16 ygyro;

		/// <summary>
		/// Angular speed around Z axis
		/// </summary>
		public Int16 zgyro;

		/// <summary>
		/// X Magnetic field
		/// </summary>
		public Int16 xmag;

		/// <summary>
		/// Y Magnetic field
		/// </summary>
		public Int16 ymag;

		/// <summary>
		/// Z Magnetic field
		/// </summary>
		public Int16 zmag;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SCALED_IMU2(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called. If there are no log files available this request shall be answered with one LOG_ENTRY message with id = 0 and num_logs = 0.
	/// </summary>
	public class Msg_log_request_list : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// First log id (0 for first available)
		/// </summary>
		public UInt16 start;

		/// <summary>
		/// Last log id (0xffff for last available)
		/// </summary>
		public UInt16 end;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOG_REQUEST_LIST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Reply to LOG_REQUEST_LIST
	/// </summary>
	public class Msg_log_entry : MavlinkMessage
    {

		/// <summary>
		/// Log id
		/// </summary>
		public UInt16 id;

		/// <summary>
		/// Total number of logs
		/// </summary>
		public UInt16 num_logs;

		/// <summary>
		/// High log number
		/// </summary>
		public UInt16 last_log_num;

		/// <summary>
		/// UTC timestamp of log since 1970, or 0 if not available
		/// </summary>
		public UInt32 time_utc;

		/// <summary>
		/// Size of the log (may be approximate)
		/// </summary>
		public UInt32 size;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOG_ENTRY(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request a chunk of a log
	/// </summary>
	public class Msg_log_request_data : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Log id (from LOG_ENTRY reply)
		/// </summary>
		public UInt16 id;

		/// <summary>
		/// Offset into the log
		/// </summary>
		public UInt32 ofs;

		/// <summary>
		/// Number of bytes
		/// </summary>
		public UInt32 count;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOG_REQUEST_DATA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Reply to LOG_REQUEST_DATA
	/// </summary>
	public class Msg_log_data : MavlinkMessage
    {

		/// <summary>
		/// Log id (from LOG_ENTRY reply)
		/// </summary>
		public UInt16 id;

		/// <summary>
		/// Offset into the log
		/// </summary>
		public UInt32 ofs;

		/// <summary>
		/// Number of bytes (zero for end of log)
		/// </summary>
		public byte count;

		/// <summary>
		/// log data
		/// </summary>
		public byte[] data; // Array size 90

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOG_DATA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Erase all logs
	/// </summary>
	public class Msg_log_erase : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOG_ERASE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Stop log transfer and resume normal logging
	/// </summary>
	public class Msg_log_request_end : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LOG_REQUEST_END(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Data for injecting into the onboard GPS (used for DGPS)
	/// </summary>
	public class Msg_gps_inject_data : MavlinkMessage
    {

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Data length
		/// </summary>
		public byte len;

		/// <summary>
		/// Raw data (110 is enough for 12 satellites of RTCMv2)
		/// </summary>
		public byte[] data; // Array size 110

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS_INJECT_DATA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Second GPS data.
	/// </summary>
	public class Msg_gps2_raw : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// GPS fix type.
		/// </summary>
		public byte fix_type;

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude (MSL). Positive for up.
		/// </summary>
		public Int32 alt;

		/// <summary>
		/// GPS HDOP horizontal dilution of position. If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 eph;

		/// <summary>
		/// GPS VDOP vertical dilution of position. If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 epv;

		/// <summary>
		/// GPS ground speed. If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 vel;

		/// <summary>
		/// Course over ground (NOT heading, but direction of movement): 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
		/// </summary>
		public UInt16 cog;

		/// <summary>
		/// Number of satellites visible. If unknown, set to 255
		/// </summary>
		public byte satellites_visible;

		/// <summary>
		/// Number of DGPS satellites
		/// </summary>
		public byte dgps_numch;

		/// <summary>
		/// Age of DGPS info
		/// </summary>
		public UInt32 dgps_age;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS2_RAW(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Power supply status
	/// </summary>
	public class Msg_power_status : MavlinkMessage
    {

		/// <summary>
		/// 5V rail voltage.
		/// </summary>
		public UInt16 Vcc;

		/// <summary>
		/// Servo rail voltage.
		/// </summary>
		public UInt16 Vservo;

		/// <summary>
		/// Bitmap of power supply status flags.
		/// </summary>
		public UInt16 flags;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_POWER_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate.
	/// </summary>
	public class Msg_serial_control : MavlinkMessage
    {

		/// <summary>
		/// Serial control device type.
		/// </summary>
		public byte device;

		/// <summary>
		/// Bitmap of serial control flags.
		/// </summary>
		public byte flags;

		/// <summary>
		/// Timeout for reply data
		/// </summary>
		public UInt16 timeout;

		/// <summary>
		/// Baudrate of transfer. Zero means no change.
		/// </summary>
		public UInt32 baudrate;

		/// <summary>
		/// how many bytes in this transfer
		/// </summary>
		public byte count;

		/// <summary>
		/// serial data
		/// </summary>
		public byte[] data; // Array size 70

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SERIAL_CONTROL(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
	/// </summary>
	public class Msg_gps_rtk : MavlinkMessage
    {

		/// <summary>
		/// Time since boot of last baseline message received.
		/// </summary>
		public UInt32 time_last_baseline_ms;

		/// <summary>
		/// Identification of connected RTK receiver.
		/// </summary>
		public byte rtk_receiver_id;

		/// <summary>
		/// GPS Week Number of last baseline
		/// </summary>
		public UInt16 wn;

		/// <summary>
		/// GPS Time of Week of last baseline
		/// </summary>
		public UInt32 tow;

		/// <summary>
		/// GPS-specific health report for RTK data.
		/// </summary>
		public byte rtk_health;

		/// <summary>
		/// Rate of baseline messages being received by GPS
		/// </summary>
		public byte rtk_rate;

		/// <summary>
		/// Current number of sats used for RTK calculation.
		/// </summary>
		public byte nsats;

		/// <summary>
		/// Coordinate system of baseline
		/// </summary>
		public byte baseline_coords_type;

		/// <summary>
		/// Current baseline in ECEF x or NED north component.
		/// </summary>
		public Int32 baseline_a_mm;

		/// <summary>
		/// Current baseline in ECEF y or NED east component.
		/// </summary>
		public Int32 baseline_b_mm;

		/// <summary>
		/// Current baseline in ECEF z or NED down component.
		/// </summary>
		public Int32 baseline_c_mm;

		/// <summary>
		/// Current estimate of baseline accuracy.
		/// </summary>
		public UInt32 accuracy;

		/// <summary>
		/// Current number of integer ambiguity hypotheses.
		/// </summary>
		public Int32 iar_num_hypotheses;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS_RTK(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
	/// </summary>
	public class Msg_gps2_rtk : MavlinkMessage
    {

		/// <summary>
		/// Time since boot of last baseline message received.
		/// </summary>
		public UInt32 time_last_baseline_ms;

		/// <summary>
		/// Identification of connected RTK receiver.
		/// </summary>
		public byte rtk_receiver_id;

		/// <summary>
		/// GPS Week Number of last baseline
		/// </summary>
		public UInt16 wn;

		/// <summary>
		/// GPS Time of Week of last baseline
		/// </summary>
		public UInt32 tow;

		/// <summary>
		/// GPS-specific health report for RTK data.
		/// </summary>
		public byte rtk_health;

		/// <summary>
		/// Rate of baseline messages being received by GPS
		/// </summary>
		public byte rtk_rate;

		/// <summary>
		/// Current number of sats used for RTK calculation.
		/// </summary>
		public byte nsats;

		/// <summary>
		/// Coordinate system of baseline
		/// </summary>
		public byte baseline_coords_type;

		/// <summary>
		/// Current baseline in ECEF x or NED north component.
		/// </summary>
		public Int32 baseline_a_mm;

		/// <summary>
		/// Current baseline in ECEF y or NED east component.
		/// </summary>
		public Int32 baseline_b_mm;

		/// <summary>
		/// Current baseline in ECEF z or NED down component.
		/// </summary>
		public Int32 baseline_c_mm;

		/// <summary>
		/// Current estimate of baseline accuracy.
		/// </summary>
		public UInt32 accuracy;

		/// <summary>
		/// Current number of integer ambiguity hypotheses.
		/// </summary>
		public Int32 iar_num_hypotheses;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS2_RTK(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units
	/// </summary>
	public class Msg_scaled_imu3 : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// X acceleration
		/// </summary>
		public Int16 xacc;

		/// <summary>
		/// Y acceleration
		/// </summary>
		public Int16 yacc;

		/// <summary>
		/// Z acceleration
		/// </summary>
		public Int16 zacc;

		/// <summary>
		/// Angular speed around X axis
		/// </summary>
		public Int16 xgyro;

		/// <summary>
		/// Angular speed around Y axis
		/// </summary>
		public Int16 ygyro;

		/// <summary>
		/// Angular speed around Z axis
		/// </summary>
		public Int16 zgyro;

		/// <summary>
		/// X Magnetic field
		/// </summary>
		public Int16 xmag;

		/// <summary>
		/// Y Magnetic field
		/// </summary>
		public Int16 ymag;

		/// <summary>
		/// Z Magnetic field
		/// </summary>
		public Int16 zmag;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SCALED_IMU3(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Handshake message to initiate, control and stop image streaming when using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
	/// </summary>
	public class Msg_data_transmission_handshake : MavlinkMessage
    {

		/// <summary>
		/// Type of requested/acknowledged data.
		/// </summary>
		public byte type;

		/// <summary>
		/// total data size (set on ACK only).
		/// </summary>
		public UInt32 size;

		/// <summary>
		/// Width of a matrix or image.
		/// </summary>
		public UInt16 width;

		/// <summary>
		/// Height of a matrix or image.
		/// </summary>
		public UInt16 height;

		/// <summary>
		/// Number of packets being sent (set on ACK only).
		/// </summary>
		public UInt16 packets;

		/// <summary>
		/// Payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only).
		/// </summary>
		public byte payload;

		/// <summary>
		/// JPEG quality. Values: [1-100].
		/// </summary>
		public byte jpg_quality;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_DATA_TRANSMISSION_HANDSHAKE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Data packet for images sent using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
	/// </summary>
	public class Msg_encapsulated_data : MavlinkMessage
    {

		/// <summary>
		/// sequence number (starting with 0 on every transmission)
		/// </summary>
		public UInt16 seqnr;

		/// <summary>
		/// image data bytes
		/// </summary>
		public byte[] data; // Array size 253

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ENCAPSULATED_DATA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Distance sensor information for an onboard rangefinder.
	/// </summary>
	public class Msg_distance_sensor : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Minimum distance the sensor can measure
		/// </summary>
		public UInt16 min_distance;

		/// <summary>
		/// Maximum distance the sensor can measure
		/// </summary>
		public UInt16 max_distance;

		/// <summary>
		/// Current distance reading
		/// </summary>
		public UInt16 current_distance;

		/// <summary>
		/// Type of distance sensor.
		/// </summary>
		public byte type;

		/// <summary>
		/// Onboard ID of the sensor
		/// </summary>
		public byte id;

		/// <summary>
		/// Direction the sensor faces. downward-facing: ROTATION_PITCH_270, upward-facing: ROTATION_PITCH_90, backward-facing: ROTATION_PITCH_180, forward-facing: ROTATION_NONE, left-facing: ROTATION_YAW_90, right-facing: ROTATION_YAW_270
		/// </summary>
		public byte orientation;

		/// <summary>
		/// Measurement variance. Max standard deviation is 6cm. 255 if unknown.
		/// </summary>
		public byte covariance;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_DISTANCE_SENSOR(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request for terrain data and terrain status
	/// </summary>
	public class Msg_terrain_request : MavlinkMessage
    {

		/// <summary>
		/// Latitude of SW corner of first grid
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude of SW corner of first grid
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Grid spacing
		/// </summary>
		public UInt16 grid_spacing;

		/// <summary>
		/// Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
		/// </summary>
		public UInt64 mask;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_TERRAIN_REQUEST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST
	/// </summary>
	public class Msg_terrain_data : MavlinkMessage
    {

		/// <summary>
		/// Latitude of SW corner of first grid
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude of SW corner of first grid
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Grid spacing
		/// </summary>
		public UInt16 grid_spacing;

		/// <summary>
		/// bit within the terrain request mask
		/// </summary>
		public byte gridbit;

		/// <summary>
		/// Terrain data MSL
		/// </summary>
		public Int16[] data; // Array size 16

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_TERRAIN_DATA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle has all terrain data needed for a mission.
	/// </summary>
	public class Msg_terrain_check : MavlinkMessage
    {

		/// <summary>
		/// Latitude
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude
		/// </summary>
		public Int32 lon;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_TERRAIN_CHECK(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Response from a TERRAIN_CHECK request
	/// </summary>
	public class Msg_terrain_report : MavlinkMessage
    {

		/// <summary>
		/// Latitude
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// grid spacing (zero if terrain at this location unavailable)
		/// </summary>
		public UInt16 spacing;

		/// <summary>
		/// Terrain height MSL
		/// </summary>
		public float terrain_height;

		/// <summary>
		/// Current vehicle height above lat/lon terrain height
		/// </summary>
		public float current_height;

		/// <summary>
		/// Number of 4x4 terrain blocks waiting to be received or read from disk
		/// </summary>
		public UInt16 pending;

		/// <summary>
		/// Number of 4x4 terrain blocks in memory
		/// </summary>
		public UInt16 loaded;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_TERRAIN_REPORT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Barometer readings for 2nd barometer
	/// </summary>
	public class Msg_scaled_pressure2 : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Absolute pressure
		/// </summary>
		public float press_abs;

		/// <summary>
		/// Differential pressure
		/// </summary>
		public float press_diff;

		/// <summary>
		/// Temperature measurement
		/// </summary>
		public Int16 temperature;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SCALED_PRESSURE2(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Motion capture attitude and position
	/// </summary>
	public class Msg_att_pos_mocap : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
		/// </summary>
		public float[] q; // Array size 4

		/// <summary>
		/// X position (NED)
		/// </summary>
		public float x;

		/// <summary>
		/// Y position (NED)
		/// </summary>
		public float y;

		/// <summary>
		/// Z position (NED)
		/// </summary>
		public float z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ATT_POS_MOCAP(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Set the vehicle attitude and body angular rates.
	/// </summary>
	public class Msg_set_actuator_control_target : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Actuator group. The "_mlx" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
		/// </summary>
		public byte group_mlx;

		/// <summary>
		/// System ID
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID
		/// </summary>
		public byte target_component;

		/// <summary>
		/// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
		/// </summary>
		public float[] controls; // Array size 8

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SET_ACTUATOR_CONTROL_TARGET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Set the vehicle attitude and body angular rates.
	/// </summary>
	public class Msg_actuator_control_target : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Actuator group. The "_mlx" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
		/// </summary>
		public byte group_mlx;

		/// <summary>
		/// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
		/// </summary>
		public float[] controls; // Array size 8

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ACTUATOR_CONTROL_TARGET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The current system altitude.
	/// </summary>
	public class Msg_altitude : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights.
		/// </summary>
		public float altitude_monotonic;

		/// <summary>
		/// This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output MSL by default and not the WGS84 altitude.
		/// </summary>
		public float altitude_amsl;

		/// <summary>
		/// This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive.
		/// </summary>
		public float altitude_local;

		/// <summary>
		/// This is the altitude above the home position. It resets on each change of the current home position.
		/// </summary>
		public float altitude_relative;

		/// <summary>
		/// This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown.
		/// </summary>
		public float altitude_terrain;

		/// <summary>
		/// This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available.
		/// </summary>
		public float bottom_clearance;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ALTITUDE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The autopilot is requesting a resource (file, binary, other type of data)
	/// </summary>
	public class Msg_resource_request : MavlinkMessage
    {

		/// <summary>
		/// Request ID. This ID should be re-used when sending back URI contents
		/// </summary>
		public byte request_id;

		/// <summary>
		/// The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
		/// </summary>
		public byte uri_type;

		/// <summary>
		/// The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum)
		/// </summary>
		public byte[] uri; // Array size 120

		/// <summary>
		/// The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
		/// </summary>
		public byte transfer_type;

		/// <summary>
		/// The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP).
		/// </summary>
		public byte[] storage; // Array size 120

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_RESOURCE_REQUEST(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Barometer readings for 3rd barometer
	/// </summary>
	public class Msg_scaled_pressure3 : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Absolute pressure
		/// </summary>
		public float press_abs;

		/// <summary>
		/// Differential pressure
		/// </summary>
		public float press_diff;

		/// <summary>
		/// Temperature measurement
		/// </summary>
		public Int16 temperature;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SCALED_PRESSURE3(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Current motion information from a designated system
	/// </summary>
	public class Msg_follow_target : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt64 timestamp;

		/// <summary>
		/// bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
		/// </summary>
		public byte est_capabilities;

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude (MSL)
		/// </summary>
		public float alt;

		/// <summary>
		/// target velocity (0,0,0) for unknown
		/// </summary>
		public float[] vel; // Array size 3

		/// <summary>
		/// linear target acceleration (0,0,0) for unknown
		/// </summary>
		public float[] acc; // Array size 3

		/// <summary>
		/// (1 0 0 0 for unknown)
		/// </summary>
		public float[] attitude_q; // Array size 4

		/// <summary>
		/// (0 0 0 for unknown)
		/// </summary>
		public float[] rates; // Array size 3

		/// <summary>
		/// eph epv
		/// </summary>
		public float[] position_cov; // Array size 3

		/// <summary>
		/// button states or switches of a tracker device
		/// </summary>
		public UInt64 custom_state;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_FOLLOW_TARGET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The smoothed, monotonic system state used to feed the control loops of the system.
	/// </summary>
	public class Msg_control_system_state : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// X acceleration in body frame
		/// </summary>
		public float x_acc;

		/// <summary>
		/// Y acceleration in body frame
		/// </summary>
		public float y_acc;

		/// <summary>
		/// Z acceleration in body frame
		/// </summary>
		public float z_acc;

		/// <summary>
		/// X velocity in body frame
		/// </summary>
		public float x_vel;

		/// <summary>
		/// Y velocity in body frame
		/// </summary>
		public float y_vel;

		/// <summary>
		/// Z velocity in body frame
		/// </summary>
		public float z_vel;

		/// <summary>
		/// X position in local frame
		/// </summary>
		public float x_pos;

		/// <summary>
		/// Y position in local frame
		/// </summary>
		public float y_pos;

		/// <summary>
		/// Z position in local frame
		/// </summary>
		public float z_pos;

		/// <summary>
		/// Airspeed, set to -1 if unknown
		/// </summary>
		public float airspeed;

		/// <summary>
		/// Variance of body velocity estimate
		/// </summary>
		public float[] vel_variance; // Array size 3

		/// <summary>
		/// Variance in local position
		/// </summary>
		public float[] pos_variance; // Array size 3

		/// <summary>
		/// The attitude, represented as Quaternion
		/// </summary>
		public float[] q; // Array size 4

		/// <summary>
		/// Angular rate in roll axis
		/// </summary>
		public float roll_rate;

		/// <summary>
		/// Angular rate in pitch axis
		/// </summary>
		public float pitch_rate;

		/// <summary>
		/// Angular rate in yaw axis
		/// </summary>
		public float yaw_rate;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_CONTROL_SYSTEM_STATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Battery information. Updates GCS with flight controller battery status. Use SMART_BATTERY_* messages instead for smart batteries.
	/// </summary>
	public class Msg_battery_status : MavlinkMessage
    {

		/// <summary>
		/// Battery ID
		/// </summary>
		public byte id;

		/// <summary>
		/// Function of the battery
		/// </summary>
		public byte battery_function;

		/// <summary>
		/// Type (chemistry) of the battery
		/// </summary>
		public byte type;

		/// <summary>
		/// Temperature of the battery. INT16_MAX for unknown temperature.
		/// </summary>
		public Int16 temperature;

		/// <summary>
		/// Battery voltage of cells. Cells above the valid cell count for this battery should have the UINT16_MAX value. If individual cell voltages are unknown or not measured for this battery, then the overall battery voltage should be filled in cell 0, with all others set to UINT16_MAX. If the voltage of the battery is greater than (UINT16_MAX - 1), then cell 0 should be set to (UINT16_MAX - 1), and cell 1 to the remaining voltage. This can be extended to multiple cells if the total voltage is greater than 2 * (UINT16_MAX - 1).
		/// </summary>
		public UInt16[] voltages; // Array size 10

		/// <summary>
		/// Battery current, -1: autopilot does not measure the current
		/// </summary>
		public Int16 current_battery;

		/// <summary>
		/// Consumed charge, -1: autopilot does not provide consumption estimate
		/// </summary>
		public Int32 current_consumed;

		/// <summary>
		/// Consumed energy, -1: autopilot does not provide energy consumption estimate
		/// </summary>
		public Int32 energy_consumed;

		/// <summary>
		/// Remaining battery energy. Values: [0-100], -1: autopilot does not estimate the remaining battery.
		/// </summary>
		public sbyte battery_remaining;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_BATTERY_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Version and capability of autopilot software. This should be emitted in response to a request with MAV_CMD_REQUEST_MESSAGE.
	/// </summary>
	public class Msg_autopilot_version : MavlinkMessage
    {

		/// <summary>
		/// Bitmap of capabilities
		/// </summary>
		public UInt64 capabilities;

		/// <summary>
		/// Firmware version number
		/// </summary>
		public UInt32 flight_sw_version;

		/// <summary>
		/// Middleware version number
		/// </summary>
		public UInt32 middleware_sw_version;

		/// <summary>
		/// Operating system version number
		/// </summary>
		public UInt32 os_sw_version;

		/// <summary>
		/// HW / board version (last 8 bytes should be silicon ID, if any)
		/// </summary>
		public UInt32 board_version;

		/// <summary>
		/// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
		/// </summary>
		public byte[] flight_custom_version; // Array size 8

		/// <summary>
		/// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
		/// </summary>
		public byte[] middleware_custom_version; // Array size 8

		/// <summary>
		/// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
		/// </summary>
		public byte[] os_custom_version; // Array size 8

		/// <summary>
		/// ID of the board vendor
		/// </summary>
		public UInt16 vendor_id;

		/// <summary>
		/// ID of the product
		/// </summary>
		public UInt16 product_id;

		/// <summary>
		/// UID if provided by hardware (see uid2)
		/// </summary>
		public UInt64 uid;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_AUTOPILOT_VERSION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The location of a landing target. See: https://mavlink.io/en/services/landing_target.html
	/// </summary>
	public class Msg_landing_target : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// The ID of the target if multiple targets are present
		/// </summary>
		public byte target_num;

		/// <summary>
		/// Coordinate frame used for following fields.
		/// </summary>
		public byte frame;

		/// <summary>
		/// X-axis angular offset of the target from the center of the image
		/// </summary>
		public float angle_x;

		/// <summary>
		/// Y-axis angular offset of the target from the center of the image
		/// </summary>
		public float angle_y;

		/// <summary>
		/// Distance to the target from the vehicle
		/// </summary>
		public float distance;

		/// <summary>
		/// Size of target along x-axis
		/// </summary>
		public float size_x;

		/// <summary>
		/// Size of target along y-axis
		/// </summary>
		public float size_y;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_LANDING_TARGET(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Status of geo-fencing. Sent in extended status stream when fencing enabled.
	/// </summary>
	public class Msg_fence_status : MavlinkMessage
    {

		/// <summary>
		/// Breach status (0 if currently inside fence, 1 if outside).
		/// </summary>
		public byte breach_status;

		/// <summary>
		/// Number of fence breaches.
		/// </summary>
		public UInt16 breach_count;

		/// <summary>
		/// Last breach type.
		/// </summary>
		public byte breach_type;

		/// <summary>
		/// Time (since boot) of last breach.
		/// </summary>
		public UInt32 breach_time;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_FENCE_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovation test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovation test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user.
	/// </summary>
	public class Msg_estimator_status : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Bitmap indicating which EKF outputs are valid.
		/// </summary>
		public UInt16 flags;

		/// <summary>
		/// Velocity innovation test ratio
		/// </summary>
		public float vel_ratio;

		/// <summary>
		/// Horizontal position innovation test ratio
		/// </summary>
		public float pos_horiz_ratio;

		/// <summary>
		/// Vertical position innovation test ratio
		/// </summary>
		public float pos_vert_ratio;

		/// <summary>
		/// Magnetometer innovation test ratio
		/// </summary>
		public float mag_ratio;

		/// <summary>
		/// Height above terrain innovation test ratio
		/// </summary>
		public float hagl_ratio;

		/// <summary>
		/// True airspeed innovation test ratio
		/// </summary>
		public float tas_ratio;

		/// <summary>
		/// Horizontal position 1-STD accuracy relative to the EKF local origin
		/// </summary>
		public float pos_horiz_accuracy;

		/// <summary>
		/// Vertical position 1-STD accuracy relative to the EKF local origin
		/// </summary>
		public float pos_vert_accuracy;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ESTIMATOR_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Wind covariance estimate from vehicle.
	/// </summary>
	public class Msg_wind_cov : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Wind in X (NED) direction
		/// </summary>
		public float wind_x;

		/// <summary>
		/// Wind in Y (NED) direction
		/// </summary>
		public float wind_y;

		/// <summary>
		/// Wind in Z (NED) direction
		/// </summary>
		public float wind_z;

		/// <summary>
		/// Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.
		/// </summary>
		public float var_horiz;

		/// <summary>
		/// Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.
		/// </summary>
		public float var_vert;

		/// <summary>
		/// Altitude (MSL) that this measurement was taken at
		/// </summary>
		public float wind_alt;

		/// <summary>
		/// Horizontal speed 1-STD accuracy
		/// </summary>
		public float horiz_accuracy;

		/// <summary>
		/// Vertical speed 1-STD accuracy
		/// </summary>
		public float vert_accuracy;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_WIND_COV(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position estimate of the system.
	/// </summary>
	public class Msg_gps_input : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// ID of the GPS for multiple GPS inputs
		/// </summary>
		public byte gps_id;

		/// <summary>
		/// Bitmap indicating which GPS input flags fields to ignore.  All other fields must be provided.
		/// </summary>
		public UInt16 ignore_flags;

		/// <summary>
		/// GPS time (from start of GPS week)
		/// </summary>
		public UInt32 time_week_ms;

		/// <summary>
		/// GPS week number
		/// </summary>
		public UInt16 time_week;

		/// <summary>
		/// 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK
		/// </summary>
		public byte fix_type;

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// Altitude (MSL). Positive for up.
		/// </summary>
		public float alt;

		/// <summary>
		/// GPS HDOP horizontal dilution of position
		/// </summary>
		public float hdop;

		/// <summary>
		/// GPS VDOP vertical dilution of position
		/// </summary>
		public float vdop;

		/// <summary>
		/// GPS velocity in north direction in earth-fixed NED frame
		/// </summary>
		public float vn;

		/// <summary>
		/// GPS velocity in east direction in earth-fixed NED frame
		/// </summary>
		public float ve;

		/// <summary>
		/// GPS velocity in down direction in earth-fixed NED frame
		/// </summary>
		public float vd;

		/// <summary>
		/// GPS speed accuracy
		/// </summary>
		public float speed_accuracy;

		/// <summary>
		/// GPS horizontal accuracy
		/// </summary>
		public float horiz_accuracy;

		/// <summary>
		/// GPS vertical accuracy
		/// </summary>
		public float vert_accuracy;

		/// <summary>
		/// Number of satellites visible.
		/// </summary>
		public byte satellites_visible;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS_INPUT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// RTCM message for injecting into the onboard GPS (used for DGPS)
	/// </summary>
	public class Msg_gps_rtcm_data : MavlinkMessage
    {

		/// <summary>
		/// LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.
		/// </summary>
		public byte flags;

		/// <summary>
		/// data length
		/// </summary>
		public byte len;

		/// <summary>
		/// RTCM message (may be fragmented)
		/// </summary>
		public byte[] data; // Array size 180

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPS_RTCM_DATA(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Message appropriate for high latency connections like Iridium
	/// </summary>
	public class Msg_high_latency : MavlinkMessage
    {

		/// <summary>
		/// Bitmap of enabled system modes.
		/// </summary>
		public byte base_mode;

		/// <summary>
		/// A bitfield for use for autopilot-specific flags.
		/// </summary>
		public UInt32 custom_mode;

		/// <summary>
		/// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
		/// </summary>
		public byte landed_state;
		public Int16 roll;
		public Int16 pitch;
		public UInt16 heading;

		/// <summary>
		/// throttle (percentage)
		/// </summary>
		public sbyte throttle;

		/// <summary>
		/// heading setpoint
		/// </summary>
		public Int16 heading_sp;
		public Int32 latitude;
		public Int32 longitude;

		/// <summary>
		/// Altitude above mean sea level
		/// </summary>
		public Int16 altitude_amsl;

		/// <summary>
		/// Altitude setpoint relative to the home position
		/// </summary>
		public Int16 altitude_sp;
		public byte airspeed;

		/// <summary>
		/// airspeed setpoint
		/// </summary>
		public byte airspeed_sp;
		public byte groundspeed;

		/// <summary>
		/// climb rate
		/// </summary>
		public sbyte climb_rate;

		/// <summary>
		/// Number of satellites visible. If unknown, set to 255
		/// </summary>
		public byte gps_nsat;

		/// <summary>
		/// GPS Fix type.
		/// </summary>
		public byte gps_fix_type;

		/// <summary>
		/// Remaining battery (percentage)
		/// </summary>
		public byte battery_remaining;

		/// <summary>
		/// Autopilot temperature (degrees C)
		/// </summary>
		public sbyte temperature;

		/// <summary>
		/// Air temperature (degrees C) from airspeed sensor
		/// </summary>
		public sbyte temperature_air;

		/// <summary>
		/// failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)
		/// </summary>
		public byte failsafe;

		/// <summary>
		/// current waypoint number
		/// </summary>
		public byte wp_num;

		/// <summary>
		/// distance to target
		/// </summary>
		public UInt16 wp_distance;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIGH_LATENCY(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Message appropriate for high latency connections like Iridium (version 2)
	/// </summary>
	public class Msg_high_latency2 : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (milliseconds since boot or Unix epoch)
		/// </summary>
		public UInt32 timestamp;

		/// <summary>
		/// Type of the MAV (quadrotor, helicopter, etc.)
		/// </summary>
		public byte type;

		/// <summary>
		/// Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.
		/// </summary>
		public byte autopilot;

		/// <summary>
		/// A bitfield for use for autopilot-specific flags (2 byte version).
		/// </summary>
		public UInt16 custom_mode;
		public Int32 latitude;
		public Int32 longitude;

		/// <summary>
		/// Altitude above mean sea level
		/// </summary>
		public Int16 altitude;

		/// <summary>
		/// Altitude setpoint
		/// </summary>
		public Int16 target_altitude;
		public byte heading;

		/// <summary>
		/// Heading setpoint
		/// </summary>
		public byte target_heading;

		/// <summary>
		/// Distance to target waypoint or position
		/// </summary>
		public UInt16 target_distance;
		public byte throttle;
		public byte airspeed;

		/// <summary>
		/// Airspeed setpoint
		/// </summary>
		public byte airspeed_sp;
		public byte groundspeed;
		public byte windspeed;

		/// <summary>
		/// Wind heading
		/// </summary>
		public byte wind_heading;

		/// <summary>
		/// Maximum error horizontal position since last message
		/// </summary>
		public byte eph;

		/// <summary>
		/// Maximum error vertical position since last message
		/// </summary>
		public byte epv;

		/// <summary>
		/// Air temperature from airspeed sensor
		/// </summary>
		public sbyte temperature_air;

		/// <summary>
		/// Maximum climb rate magnitude since last message
		/// </summary>
		public sbyte climb_rate;

		/// <summary>
		/// Battery level (-1 if field not provided).
		/// </summary>
		public sbyte battery;

		/// <summary>
		/// Current waypoint number
		/// </summary>
		public UInt16 wp_num;

		/// <summary>
		/// Bitmap of failure flags.
		/// </summary>
		public UInt16 failure_flags;

		/// <summary>
		/// Field for custom payload.
		/// </summary>
		public sbyte custom0;

		/// <summary>
		/// Field for custom payload.
		/// </summary>
		public sbyte custom1;

		/// <summary>
		/// Field for custom payload.
		/// </summary>
		public sbyte custom2;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HIGH_LATENCY2(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Vibration levels and accelerometer clipping
	/// </summary>
	public class Msg_vibration : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;

		/// <summary>
		/// Vibration levels on X-axis
		/// </summary>
		public float vibration_x;

		/// <summary>
		/// Vibration levels on Y-axis
		/// </summary>
		public float vibration_y;

		/// <summary>
		/// Vibration levels on Z-axis
		/// </summary>
		public float vibration_z;

		/// <summary>
		/// first accelerometer clipping count
		/// </summary>
		public UInt32 clipping_0;

		/// <summary>
		/// second accelerometer clipping count
		/// </summary>
		public UInt32 clipping_1;

		/// <summary>
		/// third accelerometer clipping count
		/// </summary>
		public UInt32 clipping_2;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_VIBRATION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
	/// </summary>
	public class Msg_home_position : MavlinkMessage
    {

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 latitude;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 longitude;

		/// <summary>
		/// Altitude (MSL). Positive for up.
		/// </summary>
		public Int32 altitude;

		/// <summary>
		/// Local X position of this position in the local coordinate frame
		/// </summary>
		public float x;

		/// <summary>
		/// Local Y position of this position in the local coordinate frame
		/// </summary>
		public float y;

		/// <summary>
		/// Local Z position of this position in the local coordinate frame
		/// </summary>
		public float z;

		/// <summary>
		/// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
		/// </summary>
		public float[] q; // Array size 4

		/// <summary>
		/// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
		/// </summary>
		public float approach_x;

		/// <summary>
		/// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
		/// </summary>
		public float approach_y;

		/// <summary>
		/// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
		/// </summary>
		public float approach_z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HOME_POSITION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
	/// </summary>
	public class Msg_set_home_position : MavlinkMessage
    {

		/// <summary>
		/// System ID.
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Latitude (WGS84)
		/// </summary>
		public Int32 latitude;

		/// <summary>
		/// Longitude (WGS84)
		/// </summary>
		public Int32 longitude;

		/// <summary>
		/// Altitude (MSL). Positive for up.
		/// </summary>
		public Int32 altitude;

		/// <summary>
		/// Local X position of this position in the local coordinate frame
		/// </summary>
		public float x;

		/// <summary>
		/// Local Y position of this position in the local coordinate frame
		/// </summary>
		public float y;

		/// <summary>
		/// Local Z position of this position in the local coordinate frame
		/// </summary>
		public float z;

		/// <summary>
		/// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
		/// </summary>
		public float[] q; // Array size 4

		/// <summary>
		/// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
		/// </summary>
		public float approach_x;

		/// <summary>
		/// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
		/// </summary>
		public float approach_y;

		/// <summary>
		/// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
		/// </summary>
		public float approach_z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SET_HOME_POSITION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The interval between messages for a particular MAVLink message ID. This message is the response to the MAV_CMD_GET_MESSAGE_INTERVAL command. This interface replaces DATA_STREAM.
	/// </summary>
	public class Msg_message_interval : MavlinkMessage
    {

		/// <summary>
		/// The ID of the requested MAVLink message. v1.0 is limited to 254 messages.
		/// </summary>
		public UInt16 message_id;

		/// <summary>
		/// The interval between two messages. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
		/// </summary>
		public Int32 interval_us;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MESSAGE_INTERVAL(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Provides state for additional features
	/// </summary>
	public class Msg_extended_sys_state : MavlinkMessage
    {

		/// <summary>
		/// The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration.
		/// </summary>
		public byte vtol_state;

		/// <summary>
		/// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
		/// </summary>
		public byte landed_state;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_EXTENDED_SYS_STATE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The location and information of an ADSB vehicle
	/// </summary>
	public class Msg_adsb_vehicle : MavlinkMessage
    {

		/// <summary>
		/// ICAO address
		/// </summary>
		public UInt32 ICAO_address;

		/// <summary>
		/// Latitude
		/// </summary>
		public Int32 lat;

		/// <summary>
		/// Longitude
		/// </summary>
		public Int32 lon;

		/// <summary>
		/// ADSB altitude type.
		/// </summary>
		public byte altitude_type;

		/// <summary>
		/// Altitude(ASL)
		/// </summary>
		public Int32 altitude;

		/// <summary>
		/// Course over ground
		/// </summary>
		public UInt16 heading;

		/// <summary>
		/// The horizontal velocity
		/// </summary>
		public UInt16 hor_velocity;

		/// <summary>
		/// The vertical velocity. Positive is up
		/// </summary>
		public Int16 ver_velocity;

		/// <summary>
		/// The callsign, 8+null
		/// </summary>
		public byte[] callsign; // Array size 9

		/// <summary>
		/// ADSB emitter type.
		/// </summary>
		public byte emitter_type;

		/// <summary>
		/// Time since last communication in seconds
		/// </summary>
		public byte tslc;

		/// <summary>
		/// Bitmap to indicate various statuses including valid data fields
		/// </summary>
		public UInt16 flags;

		/// <summary>
		/// Squawk code
		/// </summary>
		public UInt16 squawk;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_ADSB_VEHICLE(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Information about a potential collision
	/// </summary>
	public class Msg_collision : MavlinkMessage
    {

		/// <summary>
		/// Collision data source
		/// </summary>
		public byte src;

		/// <summary>
		/// Unique identifier, domain based on src field
		/// </summary>
		public UInt32 id;

		/// <summary>
		/// Action that is being taken to avoid this collision
		/// </summary>
		public byte action;

		/// <summary>
		/// How concerned the aircraft is about this collision
		/// </summary>
		public byte threat_level;

		/// <summary>
		/// Estimated time until collision occurs
		/// </summary>
		public float time_to_minimum_delta;

		/// <summary>
		/// Closest vertical distance between vehicle and object
		/// </summary>
		public float altitude_minimum_delta;

		/// <summary>
		/// Closest horizontal distance between vehicle and object
		/// </summary>
		public float horizontal_minimum_delta;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_COLLISION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Message implementing parts of the V2 payload specs in V1 frames for transitional support.
	/// </summary>
	public class Msg_v2_extension : MavlinkMessage
    {

		/// <summary>
		/// Network ID (0 for broadcast)
		/// </summary>
		public byte target_network;

		/// <summary>
		/// System ID (0 for broadcast)
		/// </summary>
		public byte target_system;

		/// <summary>
		/// Component ID (0 for broadcast)
		/// </summary>
		public byte target_component;

		/// <summary>
		/// A code that identifies the software component that understands this message (analogous to USB device classes or mime type strings). If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/definition_files/extension_message_ids.xml. Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
		/// </summary>
		public UInt16 message_type;

		/// <summary>
		/// Variable length payload. The length must be encoded in the payload as part of the message_type protocol, e.g. by including the length as payload data, or by terminating the payload data with a non-zero marker. This is required in order to reconstruct zero-terminated payloads that are (or otherwise would be) trimmed by MAVLink 2 empty-byte truncation. The entire content of the payload block is opaque unless you understand the encoding message_type. The particular encoding used can be extension specific and might not always be documented as part of the MAVLink specification.
		/// </summary>
		public byte[] payload; // Array size 249

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_V2_EXTENSION(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
	/// </summary>
	public class Msg_memory_vect : MavlinkMessage
    {

		/// <summary>
		/// Starting address of the debug variables
		/// </summary>
		public UInt16 address;

		/// <summary>
		/// Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
		/// </summary>
		public byte ver;

		/// <summary>
		/// Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
		/// </summary>
		public byte type;

		/// <summary>
		/// Memory contents at specified address
		/// </summary>
		public sbyte[] value; // Array size 32

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_MEMORY_VECT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// To debug something using a named 3D vector.
	/// </summary>
	public class Msg_debug_vect : MavlinkMessage
    {
		public byte[] name; // Array size 10

		/// <summary>
		/// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
		/// </summary>
		public UInt64 time_usec;
		public float x;
		public float y;
		public float z;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_DEBUG_VECT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
	/// </summary>
	public class Msg_named_value_float : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Name of the debug variable
		/// </summary>
		public byte[] name; // Array size 10

		/// <summary>
		/// Floating point value
		/// </summary>
		public float value;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_NAMED_VALUE_FLOAT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
	/// </summary>
	public class Msg_named_value_int : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Name of the debug variable
		/// </summary>
		public byte[] name; // Array size 10

		/// <summary>
		/// Signed integer value
		/// </summary>
		public Int32 value;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_NAMED_VALUE_INT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz).
	/// </summary>
	public class Msg_statustext : MavlinkMessage
    {

		/// <summary>
		/// Severity of status. Relies on the definitions within RFC-5424.
		/// </summary>
		public byte severity;

		/// <summary>
		/// Status text message, without null termination character
		/// </summary>
		public byte[] text; // Array size 50

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_STATUSTEXT(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N.
	/// </summary>
	public class Msg_debug : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// index of debug variable
		/// </summary>
		public byte ind;

		/// <summary>
		/// DEBUG value
		/// </summary>
		public float value;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_DEBUG(this, bytes, ref offset);
            }        
	}

}

